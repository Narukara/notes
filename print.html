<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>My Notes</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">1.</strong> readme</a></li><li class="chapter-item "><a href="c/title.html"><strong aria-hidden="true">2.</strong> C 语言</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/基础.html"><strong aria-hidden="true">2.1.</strong> 基础</a></li><li class="chapter-item "><a href="c/黑魔法.html"><strong aria-hidden="true">2.2.</strong> 黑魔法</a></li></ol></li><li class="chapter-item "><a href="cpp/title.html"><strong aria-hidden="true">3.</strong> C++</a></li><li class="chapter-item "><a href="Makefile/title.html"><strong aria-hidden="true">4.</strong> Makefile</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Makefile/基础.html"><strong aria-hidden="true">4.1.</strong> 基础</a></li></ol></li><li class="chapter-item "><a href="CMake/title.html"><strong aria-hidden="true">5.</strong> CMake</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="CMake/基础.html"><strong aria-hidden="true">5.1.</strong> 基础</a></li></ol></li><li class="chapter-item "><a href="Rust/title.html"><strong aria-hidden="true">6.</strong> Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Rust/工具链.html"><strong aria-hidden="true">6.1.</strong> 工具链</a></li><li class="chapter-item "><a href="Rust/变量和类型.html"><strong aria-hidden="true">6.2.</strong> 变量和类型</a></li><li class="chapter-item "><a href="Rust/常用宏.html"><strong aria-hidden="true">6.3.</strong> 常用宏</a></li><li class="chapter-item "><a href="Rust/语句&函数&注释.html"><strong aria-hidden="true">6.4.</strong> 语句&amp;函数&amp;注释</a></li><li class="chapter-item "><a href="Rust/所有权和引用.html"><strong aria-hidden="true">6.5.</strong> 所有权和引用</a></li><li class="chapter-item "><a href="Rust/slice.html"><strong aria-hidden="true">6.6.</strong> slice</a></li><li class="chapter-item "><a href="Rust/结构体.html"><strong aria-hidden="true">6.7.</strong> 结构体</a></li><li class="chapter-item "><a href="Rust/枚举.html"><strong aria-hidden="true">6.8.</strong> 枚举</a></li><li class="chapter-item "><a href="Rust/控制流.html"><strong aria-hidden="true">6.9.</strong> 控制流</a></li><li class="chapter-item "><a href="Rust/项目管理.html"><strong aria-hidden="true">6.10.</strong> 项目管理</a></li><li class="chapter-item "><a href="Rust/字符串.html"><strong aria-hidden="true">6.11.</strong> 字符串</a></li><li class="chapter-item "><a href="Rust/Vec.html"><strong aria-hidden="true">6.12.</strong> Vec</a></li><li class="chapter-item "><a href="Rust/HashMap.html"><strong aria-hidden="true">6.13.</strong> HashMap</a></li><li class="chapter-item "><a href="Rust/错误处理.html"><strong aria-hidden="true">6.14.</strong> 错误处理</a></li><li class="chapter-item "><a href="Rust/泛型.html"><strong aria-hidden="true">6.15.</strong> 泛型</a></li><li class="chapter-item "><a href="Rust/生命周期.html"><strong aria-hidden="true">6.16.</strong> 生命周期</a></li><li class="chapter-item "><a href="Rust/Trait.html"><strong aria-hidden="true">6.17.</strong> Trait</a></li><li class="chapter-item "><a href="Rust/测试.html"><strong aria-hidden="true">6.18.</strong> 测试</a></li><li class="chapter-item "><a href="Rust/闭包.html"><strong aria-hidden="true">6.19.</strong> 闭包</a></li><li class="chapter-item "><a href="Rust/迭代器.html"><strong aria-hidden="true">6.20.</strong> 迭代器</a></li><li class="chapter-item "><a href="Rust/智能指针.html"><strong aria-hidden="true">6.21.</strong> 智能指针</a></li><li class="chapter-item "><a href="Rust/并发.html"><strong aria-hidden="true">6.22.</strong> 并发</a></li><li class="chapter-item "><a href="Rust/trait对象.html"><strong aria-hidden="true">6.23.</strong> trait对象</a></li><li class="chapter-item "><a href="Rust/unsafe.html"><strong aria-hidden="true">6.24.</strong> unsafe</a></li><li class="chapter-item "><a href="Rust/宏.html"><strong aria-hidden="true">6.25.</strong> 宏</a></li></ol></li><li class="chapter-item "><a href="Git/title.html"><strong aria-hidden="true">7.</strong> Git</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Git/基础.html"><strong aria-hidden="true">7.1.</strong> 基础</a></li></ol></li><li class="chapter-item "><a href="51/title.html"><strong aria-hidden="true">8.</strong> 51单片机</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="51/串行接口.html"><strong aria-hidden="true">8.1.</strong> 串行接口</a></li><li class="chapter-item "><a href="51/定时器计数器.html"><strong aria-hidden="true">8.2.</strong> 定时器计数器</a></li><li class="chapter-item "><a href="51/中断.html"><strong aria-hidden="true">8.3.</strong> 中断</a></li><li class="chapter-item "><a href="51/储存类型.html"><strong aria-hidden="true">8.4.</strong> 储存类型</a></li></ol></li><li class="chapter-item "><a href="STM32/title.html"><strong aria-hidden="true">9.</strong> STM32</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="STM32/工具链.html"><strong aria-hidden="true">9.1.</strong> 工具链</a></li><li class="chapter-item "><a href="STM32/启动文件.html"><strong aria-hidden="true">9.2.</strong> 启动文件</a></li><li class="chapter-item "><a href="STM32/链接脚本.html"><strong aria-hidden="true">9.3.</strong> 连接脚本</a></li><li class="chapter-item "><a href="STM32/C库.html"><strong aria-hidden="true">9.4.</strong> C 库</a></li><li class="chapter-item "><a href="STM32/bootloader.html"><strong aria-hidden="true">9.5.</strong> bootloader</a></li><li class="chapter-item "><a href="STM32/下载和调试.html"><strong aria-hidden="true">9.6.</strong> 下载和调试</a></li></ol></li><li class="chapter-item "><a href="LVGL/title.html"><strong aria-hidden="true">10.</strong> LVGL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="LVGL/移植.html"><strong aria-hidden="true">10.1.</strong> 移植</a></li></ol></li><li class="chapter-item "><a href="Haskell/title.html"><strong aria-hidden="true">11.</strong> Haskell</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Haskell/函数式基础.html"><strong aria-hidden="true">11.1.</strong> 函数式基础</a></li><li class="chapter-item "><a href="Haskell/ghci.html"><strong aria-hidden="true">11.2.</strong> ghci</a></li><li class="chapter-item "><a href="Haskell/类型.html"><strong aria-hidden="true">11.3.</strong> 类型</a></li><li class="chapter-item "><a href="Haskell/表达式.html"><strong aria-hidden="true">11.4.</strong> 表达式</a></li><li class="chapter-item "><a href="Haskell/函数.html"><strong aria-hidden="true">11.5.</strong> 函数</a></li><li class="chapter-item "><a href="Haskell/工具模块和函数.html"><strong aria-hidden="true">11.6.</strong> 工具模块和函数</a></li><li class="chapter-item "><a href="Haskell/模块.html"><strong aria-hidden="true">11.7.</strong> 模块</a></li></ol></li><li class="chapter-item "><a href="Verilog/title.html"><strong aria-hidden="true">12.</strong> Verilog</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Verilog/基础.html"><strong aria-hidden="true">12.1.</strong> 基础</a></li></ol></li><li class="chapter-item "><a href="LaTeX/title.html"><strong aria-hidden="true">13.</strong> LaTeX</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="LaTeX/基础.html"><strong aria-hidden="true">13.1.</strong> 基础</a></li><li class="chapter-item "><a href="LaTeX/排版文字.html"><strong aria-hidden="true">13.2.</strong> 排版文字</a></li><li class="chapter-item "><a href="LaTeX/文档元素.html"><strong aria-hidden="true">13.3.</strong> 文档元素</a></li><li class="chapter-item "><a href="LaTeX/宏包.html"><strong aria-hidden="true">13.4.</strong> 宏包</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">My Notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Narukara/notes" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="个人学习笔记"><a class="header" href="#个人学习笔记">个人学习笔记</a></h2>
<p>放在这里做备份用，低质量警告！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-语言"><a class="header" href="#c-语言">C 语言</a></h1>
<p>大部分内容来源于 </p>
<ul>
<li>《C Primer Plus》</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="1-初识-c-语言"><a class="header" href="#1-初识-c-语言">1 初识 C 语言</a></h2>
<p>C语言标准：</p>
<ul>
<li>K&amp;R C，经典 C</li>
<li>ANSI C，ISO C，C89，C90</li>
<li>C99</li>
<li>C11</li>
</ul>
<hr />
<h2 id="3-数据和-c"><a class="header" href="#3-数据和-c">3 数据和 C</a></h2>
<h4 id="c99-新类型"><a class="header" href="#c99-新类型">C99 新类型</a></h4>
<pre><code class="language-c">_Bool a;
double _Complex b;
double _Imaginary c;
</code></pre>
<p>或者 <code>#include &lt;complex.h&gt;</code></p>
<h4 id="c99-可移植类型"><a class="header" href="#c99-可移植类型">C99 可移植类型</a></h4>
<pre><code class="language-c">#include &lt;stdint.h&gt;
int32_t i;
int_least8_t j;
int_fast8_t k;
intmax_t l;

#include &lt;inttypes.h&gt;
printf(&quot;%&quot; PRId32 &quot;\n&quot;, i);
</code></pre>
<h4 id="浮点数的上溢和下溢"><a class="header" href="#浮点数的上溢和下溢">浮点数的上溢和下溢</a></h4>
<p>...</p>
<hr />
<h2 id="5-运算符表达式和语句"><a class="header" href="#5-运算符表达式和语句">5 运算符、表达式和语句</a></h2>
<p>运算符, 表达式, 语句</p>
<p>每个表达式都有一个值</p>
<hr />
<h2 id="6-c-控制语句循环"><a class="header" href="#6-c-控制语句循环">6 C 控制语句：循环</a></h2>
<h4 id="逗号运算符"><a class="header" href="#逗号运算符">逗号运算符</a></h4>
<p>整个表达式的值是逗号右侧表达式的值</p>
<hr />
<h2 id="8-字符输入输出和输入验证"><a class="header" href="#8-字符输入输出和输入验证">8 字符输入/输出和输入验证</a></h2>
<ul>
<li>
<p>缓冲输入/无缓冲输入</p>
</li>
<li>
<p>键盘模拟文件结尾:</p>
<ul>
<li>大多数UNIX和Linux系统: 一行开始处Ctrl+D</li>
<li>许多微型计算机: 一行开始处Ctrl+Z</li>
<li>一些系统:任意位置的Ctrl+Z</li>
</ul>
</li>
<li>
<p>命令行重定向</p>
</li>
</ul>
<pre><code class="language-bash">echo_eof &lt; mywords &gt; savewords
</code></pre>
<p>重定向 stdin 为 mywords, 重定向 stdout 为 savewords</p>
<hr />
<h2 id="10-数组和指针"><a class="header" href="#10-数组和指针">10 数组和指针</a></h2>
<h4 id="数组指针指针数组"><a class="header" href="#数组指针指针数组">数组指针/指针数组</a></h4>
<pre><code class="language-c">int arr[2][3];
int(*p)[3] = arr;
void show(int array[][3], int rows);
</code></pre>
<h4 id="const-指针与安全性"><a class="header" href="#const-指针与安全性">const 指针与安全性</a></h4>
<p>...</p>
<h4 id="变长数组vla"><a class="header" href="#变长数组vla">变长数组VLA</a></h4>
<pre><code class="language-c">int n = 2, m = 3;
int arr[n][m];
void show(int n, int m, int array[n][m]);
</code></pre>
<h4 id="复合字面量"><a class="header" href="#复合字面量">复合字面量</a></h4>
<pre><code class="language-c">(int[]){1, 2, 3};
</code></pre>
<hr />
<h2 id="11-字符串和字符串函数"><a class="header" href="#11-字符串和字符串函数">11 字符串和字符串函数</a></h2>
<h4 id="数组与指针的区别"><a class="header" href="#数组与指针的区别">数组与指针的区别</a></h4>
<pre><code class="language-c">char s[] = &quot;hello&quot;;
char* p = &quot;world&quot;;
</code></pre>
<h4 id="fgets-和-fputs"><a class="header" href="#fgets-和-fputs"><code>fgets()</code> 和 <code>fputs()</code></a></h4>
<p>...</p>
<h4 id="命令行参数"><a class="header" href="#命令行参数">命令行参数</a></h4>
<pre><code class="language-c">int main(int argc, char* argv[]) {}
</code></pre>
<p>其中 <code>argv[0]</code> 是程序本身的名称</p>
<hr />
<h2 id="12-存储类别链接和内存管理"><a class="header" href="#12-存储类别链接和内存管理">12 存储类别、链接和内存管理</a></h2>
<table><thead><tr><th>储存类别</th><th>储存期</th><th>作用域</th><th>链接</th><th>声明方式</th><th>其他</th></tr></thead><tbody>
<tr><td>自动</td><td>自动</td><td>块</td><td>无</td><td>块内 (auto)</td><td></td></tr>
<tr><td>寄存器</td><td>自动</td><td>块</td><td>无</td><td>块内 register 请求</td><td>可作形参, 不能取地址</td></tr>
<tr><td>静态无链接</td><td>静态</td><td>块</td><td>无</td><td>块内 static</td><td>默认初始化为0</td></tr>
<tr><td>静态内部链接</td><td>静态</td><td>文件</td><td>内部</td><td>所有函数外 static</td><td>默认初始化为0</td></tr>
<tr><td>静态外部链接</td><td>静态</td><td>文件</td><td>外部</td><td>所有函数外</td><td>其他文件需要extern声明, 默认初始化0</td></tr>
<tr><td>动态内存分配</td><td>手动</td><td>手动</td><td>-</td><td>调用相关函数</td><td></td></tr>
</tbody></table>
<table><thead><tr><th>限定符</th><th>说明</th></tr></thead><tbody>
<tr><td>const</td><td>*前表明不能改变指针所指向的值, *后表明指针不能指向别处(指针本身的值不变)</td></tr>
<tr><td>volatile</td><td>告知编译器某一值可能被其他程序或线程改变, 阻止高速缓存优化</td></tr>
<tr><td>restrict</td><td>声明某一指针为访问所指向对象的唯一且初始的方式, 帮助编译器优化</td></tr>
<tr><td>_Atomic</td><td>多线程中的原子类型, 和原子操作配合使用</td></tr>
</tbody></table>
<hr />
<h2 id="13-文件输入输出"><a class="header" href="#13-文件输入输出">13 文件输入/输出</a></h2>
<p>文本模式/二进制模式</p>
<p>某些（非常老的）OS上会以不同的形式存储文本文件和二进制文件。另外还有行结束符之类的问题。</p>
<p>fopen()的模式字符串：注意，在所有符合 POSIX 的系统上，模式参数 <code>b</code> 事实上没有任何效果</p>
<table><thead><tr><th>模式字符串</th><th>说明</th></tr></thead><tbody>
<tr><td>r</td><td>读模式</td></tr>
<tr><td>w</td><td>写模式。把现有文件内容清空。如果文件不存在，则创建</td></tr>
<tr><td>a</td><td>写模式。在现有文件末尾添加。如果文件不存在，则创建</td></tr>
<tr><td>r+</td><td>更新模式，可以读写</td></tr>
<tr><td>w+</td><td>更新模式，可以读写。把现有文件内容清空。如果文件不存在，则创建</td></tr>
<tr><td>a+</td><td>更新模式，可以读写。在现有文件末尾添加。如果文件不存在，则创建</td></tr>
<tr><td>b</td><td>附加在上面的模式上，使用二进制模式而非文本模式。</td></tr>
<tr><td>x</td><td>C11 特性。附加在上面的模式上，如果文件已存在或以独占模式打开文件，则打开失败</td></tr>
</tbody></table>
<p>随机访问: rewind() 函数 fseek() 和 ftell() 函数, fgetpos() 和 fsetpos() 函数</p>
<p>其他标准I/O函数: ungetc(): 把指定字符放回输入流, fflush(), setvbuf()</p>
<p>二进制I/O: fread() 和 fwrite()</p>
<p>区分EOF和读取错误 feof() ferror()</p>
<hr />
<h2 id="14-结构和其他数据形式"><a class="header" href="#14-结构和其他数据形式">14 结构和其他数据形式</a></h2>
<h4 id="结构体的初始化"><a class="header" href="#结构体的初始化">结构体的初始化</a></h4>
<pre><code class="language-c">struct book {
    char name[20];
    float price;
};
struct book a = {&quot;Cpp&quot;, 9.99};
struct book b = {
    .name = &quot;Cpppp&quot;,
    .price = 19.99
};

struct box {
    int num;
    struct book inner;
};
struct box c = {1, {&quot;cpp&quot;, 9.99}};
</code></pre>
<h4 id="结构体直接拷贝"><a class="header" href="#结构体直接拷贝">结构体直接拷贝</a></h4>
<pre><code class="language-c">struct book apy = a;
</code></pre>
<p>结构作为函数参数/返回值, 或结构指针作为函数参数 优缺点</p>
<h4 id="复合字面量-1"><a class="header" href="#复合字面量-1">复合字面量</a></h4>
<pre><code class="language-c">(struct book){&quot;app&quot;, 99.99};
</code></pre>
<h4 id="伸缩型数组成员"><a class="header" href="#伸缩型数组成员">伸缩型数组成员</a></h4>
<pre><code class="language-c">struct flex {
    int num;
    int scores[];
};
struct flex* p = malloc(sizeof(struct flex) + 5 * sizeof(int));
free(p);
</code></pre>
<h4 id="联合-匿名结构-匿名联合"><a class="header" href="#联合-匿名结构-匿名联合">联合, 匿名结构, 匿名联合</a></h4>
<pre><code class="language-c">struct car {
    int status;
    union {
        int num;
        char c;
    };
};
</code></pre>
<h4 id="枚举"><a class="header" href="#枚举">枚举</a></h4>
<pre><code class="language-c">enum color { red, orange, yellow, green, blue };
enum color t = red;
switch (t) {
    case red:
        /* code */
        break;
    case orange:
        /* code */
        break;
    default:
        break;
}
</code></pre>
<h4 id="函数指针"><a class="header" href="#函数指针">函数指针</a></h4>
<pre><code class="language-c">int fun() {
    ...
}

int (*f)() = fun;

// 用 typedef 简化
typedef int (*fn_t)();
</code></pre>
<hr />
<h2 id="15-位操作"><a class="header" href="#15-位操作">15 位操作</a></h2>
<h4 id="位字段"><a class="header" href="#位字段">位字段</a></h4>
<pre><code class="language-c">struct box_props {
    bool opaque             : 1;
    unsigned int fill_color : 3;
    unsigned int            : 4;
};
struct box_props prop;
prop.opaque = true;
prop.fill_color = 4;
</code></pre>
<h4 id="对齐特性-c11"><a class="header" href="#对齐特性-c11">对齐特性 C11</a></h4>
<p>注意：对齐特性会影响结构体的大小, 设计结构体时要注意</p>
<pre><code class="language-c">size_t t = _Alignof(float);
_Alignas(4) char c1;
_Alignas(float) char c2;
</code></pre>
<hr />
<h2 id="16-c-预处理器和-c-库"><a class="header" href="#16-c-预处理器和-c-库">16 C 预处理器和 C 库</a></h2>
<h4 id="预处理前-翻译处理"><a class="header" href="#预处理前-翻译处理">预处理前: 翻译处理</a></h4>
<ol>
<li>
<p>字符扩展</p>
</li>
<li>
<p>反斜杠续行(物理行-&gt;逻辑行)</p>
</li>
<li>
<p>把文本划分呢为 预处理记号序列, 空白序列, 注释序列</p>
<p>用空格替换注释</p>
</li>
</ol>
<h4 id="宏"><a class="header" href="#宏">宏</a></h4>
<pre><code class="language-c">#undef
#ifdef
#if defined ()
#ifndef
#if
#elif
#endif
</code></pre>
<h4 id="预处理阶段"><a class="header" href="#预处理阶段">预处理阶段</a></h4>
<pre><code class="language-c">#define PSQR(x) printf(&quot;the square of &quot; #x &quot; is %d.\n&quot;,((x)*(x)))
// 三者的区别:
#define XNAME(n) xn //XNAME(1)替换成xn
#define XNAME(n) x#n //XNAME(1)替换成 x&quot;1&quot;
#define XNAME(n) x##n //XNAME(1)替换成 x1
#define XNAME(n) x##n##x //XNAME(1)替换成 x1x
</code></pre>
<p><code>##</code> 是双目运算符，用于拼接两侧的东西，gcc会检查拼接得到的东西是否是一个合法的 preprocessing token</p>
<h4 id="变参宏"><a class="header" href="#变参宏">变参宏</a></h4>
<pre><code class="language-c">#define PR(X, ...) printf(&quot;Message &quot; #X &quot;: &quot; __VA_ARGS__)
PR(1, &quot;x=%lf\n&quot;, x);
</code></pre>
<table><thead><tr><th>预定义宏</th><th>含义</th></tr></thead><tbody>
<tr><td><code>__DATE__</code></td><td>预处理的日期(&quot;MM DD YYYY&quot;形式的字符串)</td></tr>
<tr><td><code>__FILE__</code></td><td>当前源代码文件名(字符串)</td></tr>
<tr><td><code>__LINE__</code></td><td>当前源代码文件中行号(整型)</td></tr>
<tr><td><code>__STDC__</code></td><td>设置为1, 表明实现遵循C标准</td></tr>
<tr><td><code>__STDC_HOSTED__</code></td><td>本机环境设置为1, 否则设置为0</td></tr>
<tr><td><code>__STDC_VERSION__</code></td><td>支持C99标准, 设置为199901L; 支持C11标准, 设置为201112L</td></tr>
<tr><td><code>__TIME__</code></td><td>翻译代码的时间(&quot;HH:MM:SS&quot;形式的字符串)</td></tr>
<tr><td><code>__func__</code></td><td>当前函数名</td></tr>
</tbody></table>
<pre><code class="language-c">// 重置__LINE__和__FILE__报告的行号和文件名
#line 100
#line 200 &quot;cool.c&quot;

// 发出错误消息
#error Not C11

// 编译指示
#pragma

// 泛型选择C11
#define fun(X) \
    _Generic((X), int : funi, float : funf, double : fund, default : fund)(X)

int funi(int arg) {
    return arg * 2;
}
float funf(float arg) {
    return arg * 2;
}
double fund(double arg) {
    return arg * 2;
}

#define show(X) \
    printf(_Generic((X), int : &quot;%d\n&quot;, float : &quot;%f\n&quot;, double : &quot;%lf\n&quot;), X)

// 内联函数C99
inline static void fun(){};
// 内联函数必须具有内部链接, 函数的定义与调用必须在同一文件(可以include)中
// 内联是建议性的, 编译器可能拒绝

// _Noreturn函数C11, 表明一个函数调用完成后不会返回主调函数

// exit() 和 atexit()
void clean(void){};
atexit(clean); // 注册clean函数, 可以注册多个函数(至少32个)
exit(); // 执行atexit()指定的函数, 执行顺序与添加顺序相反

// 断言库 assert.h
assert(断言为真的表达式);
#define NDEBUG // 写在包含assert.h的位置前面, 自动禁用断言

// _Static_assert 编译时断言
_Static_assert(整型常量表达式, 字符串);

//可变参数 stdarg.h
...
</code></pre>
<hr />
<h2 id="17-高级数据表示"><a class="header" href="#17-高级数据表示">17 高级数据表示</a></h2>
<p>...</p>
<hr />
<p>建议将含有函数声明的 <code>.h</code> 文件 <code>include</code> 到定义函数的 <code>.c</code> 文件里，这样编译器就能检查声明和定义是否匹配。否则可能在编译和链接阶段 C 编译器都检查不出其不匹配。（对 C 语言来说非常必要，C++ 为了实现重载有 Name Mangling，因此一般能查出问题）</p>
<div style="break-before: page; page-break-before: always;"></div><p>:warning: 以下内容可能仅是 GCC 的扩展，不符合 C 标准！</p>
<p>参考 http://blogger.popcnt.org/2008/03/useful-c-extensions-gcc-specific.html 等</p>
<hr />
<h2 id="嵌套函数"><a class="header" href="#嵌套函数">嵌套函数</a></h2>
<pre><code class="language-c">int main() {
    int a = 9;

    int plus() {
        return a + 1;
    }
}
</code></pre>
<p>在一个函数内嵌套定义另一个函数。内层函数可以使用 <code>goto</code> 跳转到外面，甚至允许使用外层函数内的变量，就像闭包一样。</p>
<p>参考：https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html</p>
<ul>
<li>如果嵌套函数没有引用外层函数的变量，它会被提升为普通函数。</li>
<li>如果嵌套函数引用了外层函数的变量，它的代码会被放在外层函数的栈上。因此调用它时，要求外层函数在运行中。且要求栈可执行。</li>
</ul>
<hr />
<h2 id="圆括号包围的复合语句"><a class="header" href="#圆括号包围的复合语句">圆括号包围的复合语句</a></h2>
<p>圆括号包围的复合语句可以产生返回值，即最后一句的值。编写宏的时候常用</p>
<pre><code class="language-c">int a = ({
    int b = 0;
    b + 1;
});
</code></pre>
<hr />
<h2 id="designated-initializers"><a class="header" href="#designated-initializers">Designated Initializers</a></h2>
<blockquote>
<p>https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html</p>
</blockquote>
<pre><code class="language-c">int a[6] = { [4] = 29, [2] = 15 };
// 等价于：
int a[6] = { 0, 0, 15, 0, 29, 0 };
</code></pre>
<p>范围赋值：</p>
<pre><code class="language-c">int widths[] = { [0 ... 9] = 1, [10 ... 99] = 2, [100] = 3 };
</code></pre>
<hr />
<h2 id="向前声明"><a class="header" href="#向前声明">向前声明</a></h2>
<pre><code class="language-c">void fun(int len; char arr[len], int len) {
    //
}
</code></pre>
<p>提前声明 <code>int len</code>，以便定义 <code>char arr[len]</code>。并用分号与真正的参数列表分割</p>
<hr />
<h2 id="条件操作数省略"><a class="header" href="#条件操作数省略">条件操作数省略</a></h2>
<pre><code class="language-c">(x ? x : y)
</code></pre>
<p>等价于</p>
<pre><code class="language-c">(x ?: y)
</code></pre>
<p>如果表达式 <code>x</code> 有副作用，不希望它执行两遍，可以使用这种省略语法</p>
<hr />
<h2 id="pragma-once"><a class="header" href="#pragma-once">#pragma once</a></h2>
<p>指明 <code>.h</code> 只被包含一次。用于代替传统的：</p>
<pre><code class="language-c">#ifndef xxx
#define xxx
// ...
#endif
</code></pre>
<hr />
<h2 id="switch-case-范围"><a class="header" href="#switch-case-范围">switch case 范围</a></h2>
<p>用省略号表示范围。省略号前后需要有空格，范围不能重叠</p>
<pre><code class="language-c">case 8 ... 15:
	// ...
case 'a' ... 'c':
	// ...

</code></pre>
<hr />
<h2 id="attribute"><a class="header" href="#attribute"><strong>attribute</strong></a></h2>
<p>种类很多</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c"><a class="header" href="#c">C++</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="makefile"><a class="header" href="#makefile">Makefile</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>Makefile文件由一系列规则 (rules) 构成, 每条规则的形式如下</p>
<pre><code class="language-makefile">&lt;目标&gt; : &lt;前置条件&gt;
[tab]&lt;命令&gt;
</code></pre>
<p>目标是必须的, 前置条件和命令是可选的, 但是两者之中至少存在一个</p>
<hr />
<h2 id="目标-target"><a class="header" href="#目标-target">目标 target</a></h2>
<p>目标通常是文件名, 可以是一个或多个文件名(空格分隔), 也可以是某个操作的名字(伪目标)</p>
<p>为了避免操作名和已存在的文件名冲突, 可以将其声明为伪目标:</p>
<pre><code class="language-makefile">.PHONY: clean
clean:
	rm *.o temp
</code></pre>
<p>如果make命令运行时没有指定目标, 默认执行第一个目标</p>
<hr />
<h2 id="前置条件-prerequisites"><a class="header" href="#前置条件-prerequisites">前置条件 prerequisites</a></h2>
<p>前置条件通常是一组文件名(空格分隔), 只要有一个前置文件不存在, 或者有过更新, 目标就需要重新构建</p>
<p>如果一个文件没有前置条件, 那么这个文件不存在时, make会调用命令(哪怕这个命令并不会实际构建出这个文件), 这个文件存在时, make就不会执行任何操作</p>
<hr />
<h2 id="命令-commands"><a class="header" href="#命令-commands">命令 commands</a></h2>
<p>命令由一行或多行shell命令组成, 每行命令之前必须有一个[tab]键</p>
<hr />
<h2 id="变量和赋值"><a class="header" href="#变量和赋值">变量和赋值</a></h2>
<pre><code class="language-makefile"># 递归扩展变量，用 = 赋值
a = hello
b = $(a)
a = world
# 此时 $(b) 为 world

# 简单扩展变量，用 := 赋值
a := hello
b := $(a)
a := world
# 此时 $(b) 为 hello

# 条件赋值 ?=
# 仅当该变量尚未定义时，进行赋值
a = hello
a ?= world
b ?= world

# 追加赋值 +=
a := hello
a += world
</code></pre>
<table><thead><tr><th>自动变量</th><th>含义</th></tr></thead><tbody>
<tr><td><code>$@</code></td><td>当前目标</td></tr>
<tr><td><code>$&lt;</code></td><td>第一个前置条件</td></tr>
<tr><td><code>$^</code></td><td>所有前置条件</td></tr>
<tr><td><code>$?</code></td><td>比目标更新的所有前置条件</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody></table>
<hr />
<h2 id="模式匹配"><a class="header" href="#模式匹配">模式匹配</a></h2>
<pre><code class="language-makefile">allout = a.o b.o c.o

target : $(allout)
	gcc -o $@ $^

%.o : %.c
	gcc -o $@ -c $^
</code></pre>
<p>如以上代码所示，每次取出 allout 中的一个，匹配到 %.o 规则并构建</p>
<hr />
<h2 id="函数"><a class="header" href="#函数">函数</a></h2>
<pre><code class="language-makefile">a = *.c
# a 的值为 *.c ，并不会匹配和展开

a = $(wildcard *.c)
# 使用 wildcard 函数展开

b = $(patsubst %.c, %.o, $(a))
# patsubst 函数用于匹配和替换

c = $(addprefix app/, $(a))
# 给字符串中每个子串添加前缀

d = $(filter %.c, $(a))
# 滤出满足模式的字符串

e = $(filter-out %.c, $(a))
# 滤除满足模式的字符串
</code></pre>
<hr />
<h2 id="条件语法"><a class="header" href="#条件语法">条件语法</a></h2>
<p>条件判断有<code>ifdef</code>, <code>ifndef</code>, <code>ifeq</code>, <code>ifneq</code></p>
<pre><code class="language-makefile">ifdef foo
	...
else ifeq ($(a), hello)
	...
else
	...
endif
</code></pre>
<hr />
<h2 id="其他"><a class="header" href="#其他">其他</a></h2>
<p>以#开头表示注释</p>
<p>make会打印每条命令和注释再执行, 也叫回声(echoing), 用@开头的行关闭回声</p>
<h3 id="oneshell"><a class="header" href="#oneshell">ONESHELL</a></h3>
<p>默认情况下, 每行命令在各自单独的shell中执行, 要使两行命令在同一个shell中执行, 有两种方法:</p>
<ol>
<li>将两行命令写在一行(也可以写在两行, 在换行符前加反斜杠转义), 中间用分号分隔</li>
<li>加上<code>.ONESHELL:</code>命令</li>
</ol>
<pre><code class="language-makefile">test1 :
	export foo=bar; echo &quot;foo=[$$foo]&quot;
	
test2 :
	export foo=bar;\
	echo &quot;foo=[$$foo]&quot;
	
.ONESHELL:
test3 : 
	export foo=bar
	echo &quot;foo=[$$foo]&quot;
</code></pre>
<h3 id="override"><a class="header" href="#override">override</a></h3>
<p>调用make时，可以指定和覆盖Makefile内变量值</p>
<pre><code class="language-shell">$ make a=haha b=lala
</code></pre>
<p>若想避免被覆盖，可以在定义变量时加上override指令</p>
<pre><code class="language-makefile">override a = hello
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cmake"><a class="header" href="#cmake">CMake</a></h1>
<p>大部分内容来源于</p>
<ul>
<li>https://zhuanlan.zhihu.com/p/371257515</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>CMake 自动生成的 Makefile 不仅可以通过 make 命令构建项目生成目标文件，还支持安装（make install）、测试安装的程序是否能正确执行（make test，或者ctest）、生成当前平台的安装包（make  package）、生成源码包（make package_source）、产生 Dashboard 显示数据并上传等高级功能。</p>
<h2 id="命令行"><a class="header" href="#命令行">命令行</a></h2>
<ol>
<li>生成构建系统（生成 Makefile）</li>
</ol>
<table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody>
<tr><td>-S</td><td>指定源文件根目录，必须包含一个 CMakeLists.txt 文件</td></tr>
<tr><td>-B</td><td>指定构建目录，构建生成的中间文件和目标文件的生成路径</td></tr>
<tr><td>-D</td><td>指定变量，格式为-D &lt;var&gt;=&lt;value&gt;，-D后面的空格可以省略</td></tr>
</tbody></table>
<pre><code class="language-shell">cmake -B build -D CMAKE_BUILD_TYPE=Debug
</code></pre>
<ol start="2">
<li>执行构建</li>
</ol>
<p>可以直接在构建目录下使用 <code>make</code> 命令，或者使用 <code>cmake --build 构建目录</code> 执行构建，常用参数有</p>
<table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody>
<tr><td>--target</td><td>指定构建目标代替默认的构建目标，可以指定多个</td></tr>
<tr><td>--parallel/-j [&lt;jobs&gt;]</td><td>指定构建目标时使用的进程数</td></tr>
</tbody></table>
<h2 id="cmake-语法"><a class="header" href="#cmake-语法">CMake 语法</a></h2>
<p>CMake的命令有不同类型，包括<strong>脚本命令、项目配置命令和测试命令</strong>，细节可以查看官网<a href="https://link.zhihu.com/?target=https%3A//cmake.org/cmake/help/v3.20/manual/cmake-commands.7.html">cmake-commands</a>。</p>
<p>CMake语言在项目配置中组织为三种源文件类型：</p>
<ol>
<li>目录：CMakeLists.txt，针对的是一个目录，描述如何针对目录（Source tree）生成构建系统，会用到项目配置命令；</li>
<li>脚本：&lt;script&gt;.cmake，就是一个CMake语言的脚本文件，可使用<code>cmake -P</code>直接执行，只能包含脚本命令；</li>
<li>模块：&lt;module&gt;.cmake，实现一些模块化的功能，可以被前面两者包含，比如<code>include(CTest)</code>启用测试功能。</li>
</ol>
<h3 id="注释"><a class="header" href="#注释">注释</a></h3>
<pre><code class="language-cmake"># 注释
#[[
  注释块
  注释块
]]
</code></pre>
<h3 id="变量"><a class="header" href="#变量">变量</a></h3>
<p>使用<code>set</code>和<code>unset</code>命令设置或者取消变量</p>
<ol>
<li>一般变量，可以是字符串，数字或者列表</li>
</ol>
<pre><code class="language-cmake">set(AUTHOR Tom)
set(AUTHOR &quot;Tom Cat&quot;)
set(NUM 30)
set(ARR to be or)
set(ARR to;be;or)
# 引用一般变量：`${&lt;variable&gt;}`，在`if()`条件判断中可以简化为只用变量名`&lt;variable&gt;`
</code></pre>
<ol start="2">
<li>Cache 变量，一般用于提供配置选项，如果用户没有指定，则使用默认值</li>
</ol>
<pre><code class="language-cmake"># set(&lt;variable&gt; &lt;value&gt;... CACHE &lt;type&gt; &lt;docstring&gt; [FORCE])
set(CVAR &quot;Default cache value&quot; CACHE STRING &quot;A sample for cache variable&quot;)
# 引用 CACHE 变量：$CACHE{&lt;varialbe&gt;}
# Cache 变量会被保存在构建目录下的 CMakeCache.txt 中，缓存起来之后是不变的，除非重新配置更新
</code></pre>
<ol start="3">
<li>环境变量</li>
</ol>
<pre><code class="language-cmake"># 修改当前进程的环境变量，设置和引用格式为：
set(ENV{&lt;variable&gt;} [&lt;value&gt;])
$ENV{&lt;varialbe&gt;}
</code></pre>
<ol start="4">
<li>内置变量</li>
</ol>
<p><code>CMAKE_</code>、<code>_CMAKE</code>或者以下划线开头后面加上任意 CMake 命令的变量。通过修改这些变量的值来配置 CMake 构建的行为</p>
<h3 id="条件语句"><a class="header" href="#条件语句">条件语句</a></h3>
<ol>
<li>字符串比较，比如：STREQUAL、STRLESS、STRGREATER等；</li>
<li>数值比较，比如：EQUAL、LESS、GREATER等；</li>
<li>布尔运算，AND、OR、NOT；</li>
<li>路径判断，比如：EXISTS、IS_DIRECTORY、IS_ABSOLUTE等；</li>
<li>版本号判断；等等；</li>
<li>使用小括号可以组合多个条件语句，比如：(cond1) AND (cond2 OR (cond3))。</li>
</ol>
<p>对于常量：</p>
<ol>
<li>ON、YES、TRUE、Y和非0值均被视为<code>True</code>；</li>
<li>0、OFF、NO、FALSE、N、IGNORE、空字符串、NOTFOUND、及以&quot;-NOTFOUND&quot;结尾的字符串均视为<code>False</code>。</li>
</ol>
<p>对于变量，只要其值不是常量中为<code>False</code>的情形，则均视为<code>True</code>。</p>
<pre><code class="language-cmake">set(EMPTY_STR &quot;&quot;)
if ((NOT EMPTY_STR) AND FLAG AND (NUM LESS 50) AND (NOT NOT_DEFINE_VAR))
    message(&quot;The first if branch...&quot;)
elseif (EMPTY_STR)
    message(&quot;EMPTY_STR is not empty&quot;)
else ()
    message(&quot;All other case&quot;)
endif()
</code></pre>
<h3 id="消息打印"><a class="header" href="#消息打印">消息打印</a></h3>
<pre><code class="language-cmake">message([&lt;mode&gt;] &quot;message text&quot; ...)
</code></pre>
<table><thead><tr><th>信息等级 &lt;mode&gt;</th><th>说明</th></tr></thead><tbody>
<tr><td>空或者<code>NOTICE</code></td><td>比较重要的信息</td></tr>
<tr><td>DEBUG</td><td>调试信息，主要针对开发者</td></tr>
<tr><td>STATUS</td><td>项目使用者可能比较关心的信息，比如提示当前使用的编译器</td></tr>
<tr><td>WARNING</td><td>CMake警告，不会打断进程</td></tr>
<tr><td>SEND_ERROR</td><td>CMake错误，会继续执行，但是会跳过生成构建系统</td></tr>
<tr><td>FATAL_ERROR</td><td>CMake致命错误，会终止进程</td></tr>
</tbody></table>
<h3 id="列表操作"><a class="header" href="#列表操作">列表操作</a></h3>
<p><code>list</code> 命令用于列表操作，有很多子命令：</p>
<ol>
<li><code>APPEND</code>，往列表中添加元素；</li>
<li><code>LENGTH</code>，获取列表元素个数；</li>
<li><code>JOIN</code>，将列表元素用指定的分隔符连接起来；</li>
</ol>
<h3 id="文件操作"><a class="header" href="#文件操作">文件操作</a></h3>
<p><code>file</code> 命令用于文件操作，有很多子命令，可以读写、创建或复制文件和目录、计算文件hash、下载文件、压缩文件、递归查找文件等</p>
<pre><code class="language-cmake"># 查找 src/ 下所有 .c 文件
file(GLOB_RECURSE ALL_SRC src/*.c)
# 或者
aux_source_directory(src ALL_SRC)
</code></pre>
<h3 id="配置文件生成"><a class="header" href="#配置文件生成">配置文件生成</a></h3>
<p>使用 <code>configure_file</code> 命令可以将 配置文件模板 中的特定内容替换，生成 目标文件。 输入文件中的<code>@VAR@</code>或者<code>${VAR}</code>在输出文件中将被对应的变量值替换。</p>
<p>例如有配置文件模板 <code>version.h.in</code></p>
<pre><code class="language-c">#define VERSION &quot;@VERSION@&quot;
</code></pre>
<p>执行 CMake 脚本</p>
<pre><code class="language-cmake">set(VERSION 1.0.0)
configure_file(version.h.in &quot;${PROJECT_SOURCE_DIR}/version.h&quot;)
</code></pre>
<p>得到 <code>version.h</code></p>
<pre><code class="language-c">#define VERSION &quot;1.0.0&quot;
</code></pre>
<h3 id="执行系统命令"><a class="header" href="#执行系统命令">执行系统命令</a></h3>
<pre><code class="language-cmake">execute_process(COMMAND bash &quot;-c&quot; &quot;git rev-parse --short HEAD&quot; OUTPUT_VARIABLE COMMIT_ID)
</code></pre>
<h3 id="查找库文件"><a class="header" href="#查找库文件">查找库文件</a></h3>
<pre><code class="language-cmake">find_library(&lt;VAR&gt; name1 [path1 path2 ...])
</code></pre>
<p>找到的库就可以被其他target使用，表明依赖关系。</p>
<h3 id="导入其他模块"><a class="header" href="#导入其他模块">导入其他模块</a></h3>
<pre><code class="language-cmake">include(CTest) # 将cmake文件或者模块加载并执行
</code></pre>
<p>CMake自带有很多有用的模块，官网链接：<a href="https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html">cmake-modules</a></p>
<h2 id="项目配置"><a class="header" href="#项目配置">项目配置</a></h2>
<h3 id="设置项目名称版本号"><a class="header" href="#设置项目名称版本号">设置项目名称&amp;版本号</a></h3>
<pre><code class="language-cmake">project(CMakeTemplate VERSION 1.0.0 LANGUAGES C CXX)
</code></pre>
<p>CMake 会将版本号各值（major.minor.patch.tweak）分别赋值给以下变量</p>
<pre><code class="language-cmake">PROJECT_VERSION, &lt;PROJECT-NAME&gt;_VERSION
PROJECT_VERSION_MAJOR, &lt;PROJECT-NAME&gt;_VERSION_MAJOR
PROJECT_VERSION_MINOR, &lt;PROJECT-NAME&gt;_VERSION_MINOR
PROJECT_VERSION_PATCH, &lt;PROJECT-NAME&gt;_VERSION_PATCH
PROJECT_VERSION_TWEAK, &lt;PROJECT-NAME&gt;_VERSION_TWEAK
</code></pre>
<p>配合 <code>configure_file</code> 命令，可以方便地在代码中得到版本信息</p>
<h3 id="指定cc标准"><a class="header" href="#指定cc标准">指定C/C++标准</a></h3>
<pre><code class="language-cmake">set(CMAKE_C_STANDARD 99)
set(CMAKE_CXX_STANDARD 11)
</code></pre>
<h3 id="编译选项编译类型"><a class="header" href="#编译选项编译类型">编译选项&amp;编译类型</a></h3>
<pre><code class="language-cmake">add_compile_options(-Wall -Wextra -pedantic -Werror)		# 为所有编译器配置编译选项
set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -pipe -std=c99&quot;)		# 为 c 编译器配置
set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -pipe -std=c++11&quot;)	# 为 c++ 编译器配置
</code></pre>
<p>通过设置变量<code>CMAKE_BUILD_TYPE</code>来配置编译类型，可设置为：<code>Debug</code>、<code>Release</code>、<code>RelWithDebInfo</code>、<code>MinSizeRel</code>。一般在执行<code>cmake</code>命令的时候通过参数<code>-D</code>指定</p>
<p>可以针对不同的编译类型设置不同的编译选项，例如：</p>
<pre><code class="language-cmake">set(CMAKE_C_FLAGS_DEBUG &quot;${CMAKE_C_FLAGS_DEBUG} -g -O0&quot;)
set(CMAKE_C_FLAGS_RELEASE &quot;${CMAKE_C_FLAGS_RELEASE} -O2&quot;)
</code></pre>
<h3 id="宏定义"><a class="header" href="#宏定义">宏定义</a></h3>
<p>添加全局的宏定义</p>
<pre><code class="language-cmake">add_definitions(-DDEBUG -DREAL_COOL_ENGINEER)
</code></pre>
<h3 id="添加-include-目录"><a class="header" href="#添加-include-目录">添加 include 目录</a></h3>
<p>添加头文件的搜索目录</p>
<pre><code class="language-cmake">include_directories(src/c)
</code></pre>
<h3 id="设置编译目标"><a class="header" href="#设置编译目标">设置编译目标</a></h3>
<p>编译目标 (target) 的类型包括静态库、动态库和可执行文件</p>
<ol>
<li>编译为静态/动态库</li>
</ol>
<p>使用命令 <code>add_library(库名称 STATIC 所有源文件)</code> 编译静态库，例如</p>
<pre><code class="language-cmake">file(GLOB_RECURSE MATH_SRC components/math/*.c)
add_library(math STATIC ${MATH_SRC})
</code></pre>
<p>指定为<code>SHARED</code>则编译为动态库</p>
<ol start="2">
<li>编译为可执行文件</li>
</ol>
<pre><code class="language-cmake">add_executable(demo main/main.c)	# (名称 所有源文件)
target_link_libraries(demo math)	# 指定依赖的库
</code></pre>
<h3 id="安装打包测试"><a class="header" href="#安装打包测试">安装&amp;打包&amp;测试</a></h3>
<p>https://zhuanlan.zhihu.com/p/371257515</p>
<h2 id="模块化构建"><a class="header" href="#模块化构建">模块化构建</a></h2>
<p><code>CMakeLists.txt</code>定义一个目录的构建系统。模块化构建就是分别为每一个子模块目录编写一个<code>CMakeLists.txt</code>，在父目录中导入子目录的构建系统的生成目标，以便在父目录中使用。</p>
<ol>
<li>在子模块目录编写 <code>CMakeLists.txt</code>，目标设置为静态库</li>
<li>在父目录中导入子模块</li>
</ol>
<pre><code class="language-cmake">add_subdirectory(components/math)	# 导入子模块
add_executable(demo main/main.c)	# 顶层目标
target_link_libraries(demo math)	# 指定依赖的库（子模块）
</code></pre>
<blockquote>
<p>通常，用 add_subdirectory 导入的子模块在项目的子目录下，例如子模块在 <code>components/math</code> 下，那么编译产生的文件放在 <code>build/components/math</code> 下。如果子模块在项目外，就需要自行指定在 <code>build</code> 下存放的位置：</p>
<pre><code class="language-cmake">add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])
</code></pre>
</blockquote>
<p>另外，也可以直接导入已编译好的目标文件：</p>
<pre><code class="language-cmake">add_library(math STATIC IMPORTED)
set_property(TARGET math PROPERTY IMPORTED_LOCATION &quot;./lib/libmath.a&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<p>大部分内容来源于</p>
<ul>
<li>https://github.com/KaiserY/trpl-zh-cn</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rustc"><a class="header" href="#rustc">rustc</a></h2>
<p>编译器</p>
<h2 id="cargo"><a class="header" href="#cargo">cargo</a></h2>
<h4 id="创建新项目"><a class="header" href="#创建新项目">创建新项目</a></h4>
<pre><code class="language-shell">cargo new name			# 二进制 crate
cargo new --lib name	# 库 crate
</code></pre>
<h4 id="构建"><a class="header" href="#构建">构建</a></h4>
<p>发布配置：即编译的配置，有两个主要的配置，<code>dev</code> 和 <code>release</code>。
自定义发布配置：<code>dev</code> 和 <code>release</code> 都有默认的配置，可以在 <code>Cargo.toml</code> 中覆盖一部分的默认配置，例如：</p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p>构建命令：</p>
<pre><code class="language-shell">cargo build
cargo build --release
</code></pre>
<ol>
<li>
<p>调试（debug）构建：默认的构建方法，采用 <code>dev</code> 配置，可执行文件生成在 <code>./target/debug/项目名</code></p>
</li>
<li>
<p>发布（release）构建，采用 <code>release</code> 配置，生成在 <code>target/release</code>，发布构建会做更多优化，使代码运行得更快：</p>
</li>
</ol>
<p>构建并运行：</p>
<pre><code class="language-shell">cargo run
</code></pre>
<p>后面添加的参数会交给编译得到的程序</p>
<p>另外，可以使用 <code>cargo check</code> 快速检查代码是否能通过编译</p>
<h4 id="测试"><a class="header" href="#测试">测试</a></h4>
<pre><code class="language-shell">cargo test
</code></pre>
<p>更多信息见 <code>测试.md</code></p>
<h4 id="文档"><a class="header" href="#文档">文档</a></h4>
<pre><code class="language-shell">cargo doc
</code></pre>
<p>构建当前 crate（包括所有依赖）的文档，放在 <code>target/doc</code></p>
<pre><code class="language-shell"> cargo doc --open
</code></pre>
<p>构建文档并在浏览器中打开</p>
<h4 id="install"><a class="header" href="#install">install</a></h4>
<p>使用 <code>cargo install xxx</code> 命令可以从 <code>crates.io</code> 安装二进制 <code>crate</code>，默认将可执行文件安装到 <code>~/.cargo/bin</code></p>
<h4 id="自定义扩展命令"><a class="header" href="#自定义扩展命令">自定义扩展命令</a></h4>
<p>如果 <code>PATH</code> 中有类似 <code>cargo-xxx</code> 的可执行文件，就可以通过 <code>cargo xxx</code> 来运行</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="变量-1"><a class="header" href="#变量-1">变量</a></h2>
<p>rust 中的变量和函数使用 snake case 规范命名。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;		// 不可变变量
let mut v = 2;	// 可变变量
const NUM: u32 = 12 * 2;	// 常量，必须注明类型
<span class="boring">}
</span></code></pre></pre>
<p>变量不能声明在全局作用域中，常量可以</p>
<p>可以重复声明同名变量，这会<strong>隐藏</strong>（Shadowing）先前的变量</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;
{
    let x = 12;
    println!(&quot;{x}&quot;);	// -&gt; 12
}
let x = x + 1;
println!(&quot;{x}&quot;);	// -&gt; 2
<span class="boring">}
</span></code></pre></pre>
<h2 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h2>
<ul>
<li><strong>标量</strong>（scalar）类型：整型、浮点型、布尔类型、字符类型</li>
<li><strong>复合</strong>（compound）类型：元组、数组</li>
</ul>
<h4 id="整型"><a class="header" href="#整型">整型</a></h4>
<table><thead><tr><th>长度（bit）</th><th>有符号</th><th>无符号</th></tr></thead><tbody>
<tr><td>8</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>arch（机器字长）</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<table><thead><tr><th>字面值</th><th>说明</th></tr></thead><tbody>
<tr><td><code>98_222</code></td><td>10进制</td></tr>
<tr><td><code>0xff</code></td><td>16进制</td></tr>
<tr><td><code>0o77</code></td><td>8进制</td></tr>
<tr><td><code>0b1111_0000</code></td><td>2进制</td></tr>
<tr><td><code>b'A'</code></td><td>字符（u8）</td></tr>
</tbody></table>
<p>整型溢出：在 debug 构建中，rust 会检查溢出并产生 panic。在 release 构建中，rust 不检查溢出。如果需要利用溢出行为，建议使用标准库的 <code>Wrapping</code> 类型。</p>
<h4 id="浮点型"><a class="header" href="#浮点型">浮点型</a></h4>
<table><thead><tr><th>长度（bit）</th><th>类型</th></tr></thead><tbody>
<tr><td>32（单精度）</td><td><code>f32</code></td></tr>
<tr><td>64（双精度）</td><td><code>f64</code></td></tr>
</tbody></table>
<h4 id="布尔型"><a class="header" href="#布尔型">布尔型</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let b: bool = true;
let b: bool = false;
<span class="boring">}
</span></code></pre></pre>
<h4 id="字符类型"><a class="header" href="#字符类型">字符类型</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let c: char = '😈';
<span class="boring">}
</span></code></pre></pre>
<p>char 类型的大小是4个字节，表示 Unicode 值</p>
<h4 id="元组-tuple"><a class="header" href="#元组-tuple">元组 tuple</a></h4>
<p>长度和类型固定，类型不必相同</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup: (i32, f32, u8) = (500, 1.0, b'A');
let tup = (1,);
<span class="boring">}
</span></code></pre></pre>
<p>模式匹配和解构</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (x, y, z) = tup;
let a = tup.0;
<span class="boring">}
</span></code></pre></pre>
<p>不包含任何值的元组 <code>()</code>，叫做<strong>单元</strong>（unit）元组。用于表示空值，如果一个表达式不返回任何值，则其隐式返回 <code>()</code>。</p>
<h4 id="数组-array"><a class="header" href="#数组-array">数组 array</a></h4>
<p>数组长度固定，在栈上分配</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
let a = [3; 5];		// 5个3
<span class="boring">}
</span></code></pre></pre>
<p>索引。越界会引起 panic。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a[3];
<span class="boring">}
</span></code></pre></pre>
<hr />
<h2 id="高级特性"><a class="header" href="#高级特性">高级特性</a></h2>
<h4 id="类型别名"><a class="header" href="#类型别名">类型别名</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Kilometers = i32;
type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>类型别名不会创建出新的类型</p>
<h4 id="never-type"><a class="header" href="#never-type">never type</a></h4>
<p>用 <code>!</code> 表示。充当从不返回的函数的返回值。从不返回的函数也叫发散函数。例子有 <code>continue</code>，<code>panic!</code>，没有 <code>break</code> 的 <code>loop</code> 等。<code>!</code> 类型可以转为任意类型，于是可以保证 <code>match</code> 分支的类型匹配。</p>
<h4 id="动态大小类型和-sized-trait"><a class="header" href="#动态大小类型和-sized-trait">动态大小类型和 <code>Sized</code> trait</a></h4>
<p>动态大小类型是在编译期不能确定大小的类型，例如 <code>str</code>、trait 对象。处理这种类型的方法是：必须将动态大小类型的值置于某种指针之后。例如 <code>&amp;dyn Trait</code>、<code>Box&lt;dyn Trait&gt;</code>、<code>Rc&lt;dyn Trait&gt;</code>。</p>
<p><code>Sized</code> trait 用于标识具有静态大小的类型，这个 trait 自动实现在编译期可以确定大小的类型上。Rust 隐式的为每一个泛型函数添加了 <code>Sized</code> bound，例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T&gt;(t: T)
<span class="boring">}
</span></code></pre></pre>
<p>事实上为：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T: Sized&gt;(t: T)
<span class="boring">}
</span></code></pre></pre>
<p>即限定了 <code>T</code> 必须是具有静态大小的类型。可以通过手动添加 <code>?Sized</code> 以解除这个限制，同时也就必须用某种指针来处理这个类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T: ?Sized&gt;(t: &amp;T)
<span class="boring">}
</span></code></pre></pre>
<h4 id="原始标识符"><a class="header" href="#原始标识符">原始标识符</a></h4>
<p>原始标识符允许你使用关键字作为变量/函数名，加上 <code>r#</code> 前缀即可，例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn r#match() {..}
let r#try = 1;
<span class="boring">}
</span></code></pre></pre>
<p>在定义和使用时都要加 <code>r#</code>。主要用于与其他语言交互。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="打印输出"><a class="header" href="#打印输出">打印输出</a></h2>
<h4 id="println"><a class="header" href="#println"><code>println!</code></a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 4;
println!(&quot;{}&quot;, a);
println!(&quot;{a}&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><code>println!</code> 宏会以不可变的形式借用变量。<code>print!</code> 同理。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Fun {
    num: u32,
}

fn main() {
    let f = fun { num: 1 };
    println!(&quot;{:#?}&quot;, f);
}
</code></pre></pre>
<p>使用 <code>{:?}</code> 或 <code>{:#?}</code> 显示附加了 <code>#[derive(Debug)]</code> 的类型</p>
<h4 id="eprintln"><a class="header" href="#eprintln"><code>eprintln!</code></a></h4>
<p><code>eprintln!</code> 和 <code>eprint!</code> 将输出到标准错误流</p>
<h4 id="format"><a class="header" href="#format"><code>format!</code></a></h4>
<p>和 <code>print!</code> 相同，但会把生成的字符串返回</p>
<h4 id="dbg"><a class="header" href="#dbg"><code>dbg!</code></a></h4>
<p><code>dbg!</code> 接收一个表达式的所有权，打印所在文件和行号，以及表达式值，最后返回该值的所有权</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = dbg!(12 * 3);
<span class="boring">}
</span></code></pre></pre>
<p><code>dbg!</code> 会输出到标准错误流 <code>stderr</code>。打印的对象需要派生 <code>Debug</code> trait。如果不希望 <code>dbg!</code> 取得变量的所有权，可以给它传递引用。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Fun {
    num: u32,
}

fn main() {
    let f = fun { num: 1 };
    dbg!(&amp;f);
}
</code></pre></pre>
<h4 id="panic"><a class="header" href="#panic"><code>panic!</code></a></h4>
<p>可以指定输出的信息</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>panic!(&quot;error in: {}&quot;, err);
<span class="boring">}
</span></code></pre></pre>
<p>更多信息见 <code>错误处理.md</code></p>
<h2 id="占位"><a class="header" href="#占位">占位</a></h2>
<h4 id="todo"><a class="header" href="#todo"><code>todo!</code></a></h4>
<h4 id="unimplemented"><a class="header" href="#unimplemented"><code>unimplemented!</code></a></h4>
<h4 id="unreachable"><a class="header" href="#unreachable"><code>unreachable!</code></a></h4>
<h2 id="测试常用宏"><a class="header" href="#测试常用宏">测试常用宏</a></h2>
<p>见 <code>测试.md</code></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="表达式和语句"><a class="header" href="#表达式和语句">表达式和语句</a></h2>
<p>表达式计算出一个值，语句不返回值。函数调用、宏调用、用大括号创建的块是表达式。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let y = {
    let x = 3;
    x + 1
};
<span class="boring">}
</span></code></pre></pre>
<p>表达式（<code>x + 1</code>）的结尾没有分号。在表达式的结尾加上分号就变成了语句。</p>
<h2 id="函数-1"><a class="header" href="#函数-1">函数</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(x: i32, y: i32) -&gt; i32 {
    println!(&quot;{} + {}&quot;, x, y);
    x + y
}
<span class="boring">}
</span></code></pre></pre>
<p>函数定义位置可以在调用位置之前或之后，只要在调用之处可见的作用域内即可。</p>
<p>函数的返回值为函数体最后一个表达式的值，使用 <code>return</code> 关键字可以提前返回。</p>
<p>允许在函数的参数位置上使用模式匹配：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Current location: ({}, {})&quot;, x, y);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="注释-1"><a class="header" href="#注释-1">注释</a></h2>
<h4 id="单行注释"><a class="header" href="#单行注释">单行注释</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 单行注释...
<span class="boring">}
</span></code></pre></pre>
<h4 id="文档注释"><a class="header" href="#文档注释">文档注释</a></h4>
<ol>
<li>以 <code>///</code> 起始，注释说明其后的对象（函数等）</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li>以 <code>//!</code> 起始，常用于注释当前 <code>crate</code> 或模块</li>
</ol>
<p><code>cargo test</code> 也会运行文档注释中的代码</p>
<hr />
<h2 id="高级特性-1"><a class="header" href="#高级特性-1">高级特性</a></h2>
<h4 id="函数指针-1"><a class="header" href="#函数指针-1">函数指针</a></h4>
<p>可以将函数名作为函数指针使用，函数指针是具体类型，且实现了所有三个闭包 trait（<code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code>），因此可以在所有需要闭包的地方使用函数指针。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(f(arg))
}

do_twice(add_one, 1)
<span class="boring">}
</span></code></pre></pre>
<p>与闭包不同的是，对于相同签名的函数，其函数指针具有相同类型。函数指针也可以作为返回值。</p>
<p>另外，元组结构体等对象的名称可以作为函数指针使用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Demo(i32);
let list: Vec&lt;Demo&gt; = (0..10).map(Demo).collect();
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="所有权"><a class="header" href="#所有权">所有权</a></h2>
<p>所有权（ownership）系统的主要目的在于管理堆上的数据。</p>
<ol>
<li>Rust 中每一个值都有一个所有者（owner）</li>
<li>值在任一时刻有且只有一个所有者</li>
<li>当所有者（变量）离开作用域（scope），这个值将被丢弃（调用 <code>drop</code> 函数）</li>
</ol>
<h4 id="移动"><a class="header" href="#移动">移动</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;some&quot;);
let s2 = s1;
println!(&quot;{},{}&quot;, s1, s2);	// error: borrow of moved value: `s1`
<span class="boring">}
</span></code></pre></pre>
<img src="Rust/assets/image-20221212180840596.png" alt="image-20221212180840596" style="zoom:67%;" />
<p>String 对象包含两个部分：</p>
<ol>
<li>堆上的部分，长度可变的字符串</li>
<li>栈上的部分，指向字符串的指针、长度、容量</li>
</ol>
<p>执行 <code>s2 = s1</code> 时，不会拷贝堆上的部分。并且在 <code>s2 = s1</code> 之后，<code>s1</code> 失效，不允许再使用。即产生了移动（move）操作。</p>
<h4 id="克隆"><a class="header" href="#克隆">克隆</a></h4>
<p>如果确实需要拷贝堆上的数据，可以使用名为 <code>clone</code> 的通用函数。克隆（clone）操作后，原先的变量仍然可用。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;some&quot;);
let s2 = s1.clone();
println!(&quot;{},{}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<h4 id="拷贝"><a class="header" href="#拷贝">拷贝</a></h4>
<p>对于仅存储在栈上的数据，或者实现了 <code>Copy</code> trait 注解的类型，使用 <code>=</code> 会产生拷贝（copy）操作。拷贝后，原先的变量仍然可用。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;
println!(&quot;{},{}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>不允许自身或其任何部分实现了 <code>Drop</code> trait 的类型使用 <code>Copy</code> trait。实现 <code>Copy</code> 的类型有：</p>
<ol>
<li>整型、浮点型、布尔型、字符类型</li>
<li>数组和元组，当且仅当其包含的类型都实现了 <code>Copy</code></li>
</ol>
<h4 id="参数和返回值"><a class="header" href="#参数和返回值">参数和返回值</a></h4>
<p>参数和返回值的传递与赋值过程相同：</p>
<pre><pre class="playground"><code class="language-rust">fn take_and_give_back(s: String) -&gt; String {
    s
}

fn main() {
    let s1 = String::from(&quot;hello&quot;);
    let s2 = take_and_give_back(s1);	// s1 移动到函数内。函数返回值移动给 s2
}	// s1, s2 离开作用域。s1 已被移动走，不做处理。s2 调用 drop。
</code></pre></pre>
<h2 id="引用和借用"><a class="header" href="#引用和借用">引用和借用</a></h2>
<p>引用（reference）类似于指针。引用允许你使用值但不获取其所有权。创建引用的行为称为借用（borrowing）。</p>
<pre><pre class="playground"><code class="language-rust">fn get_len(s: &amp;String) -&gt; usize {
    s.len()
}	// 不会调用 drop

fn main() {
    let s1 = String::from(&quot;hello&quot;);
    let len = get_len(&amp;s1);
    // s1 仍然可用
}
</code></pre></pre>
<img src="Rust/assets/image-20221212201108583.png" alt="image-20221212201108583" style="zoom: 67%;" />
<blockquote>
<p>与引用相反的操作是解引用（dereferencing），使用 <code>*</code> 运算符</p>
</blockquote>
<h4 id="可变引用"><a class="header" href="#可变引用">可变引用</a></h4>
<p>引用默认不可变。添加 <code>mut</code> 关键字创建可变引用。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn change(s: &amp;mut String) {
    s.push_str(&quot;some&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;hello&quot;);
let r1 = &amp;mut s;
<span class="boring">}
</span></code></pre></pre>
<p>为了避免数据竞争，对于同一个对象，在同一时刻：</p>
<ul>
<li>要么只有一个可变引用，没有其他引用</li>
<li>要么只有若干个不可变引用，没有可变引用</li>
</ul>
<p>引用有效的范围是从声明的位置到最后一次使用，以此为标准来判断上面的“同一时刻”。</p>
<h4 id="悬垂"><a class="header" href="#悬垂">悬垂</a></h4>
<p>在有指针的语言中，可能存在悬垂指针问题。指即针指向的对象已经被释放。Rust 通过声明周期机制保证引用不会处于悬垂状态。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="slice"><a class="header" href="#slice">slice</a></h2>
<p>slice 类型允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 是引用。slice 对象包含首元素的引用和长度</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3];	// [i32; 3]
let s = &amp;a[1..];	// &amp;[i32]
<span class="boring">}
</span></code></pre></pre>
<p>slice 可以是 mut 引用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = [1, 2, 3];	// [i32; 3]
let s = &amp;mut a[1..];	// &amp;mut [i32]
s[0] = 99;
<span class="boring">}
</span></code></pre></pre>
<h4 id="字符串-slice"><a class="header" href="#字符串-slice">字符串 slice</a></h4>
<p>String 的 slice 类型为 <code>&amp;str</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello world&quot;);

let r = &amp;s;			// &amp;String

let all = &amp;s[..];	// &amp;str
let hello = &amp;s[0..5];
let world = &amp;s[6..];
<span class="boring">}
</span></code></pre></pre>
<img src="Rust/assets/image-20221212224345186.png" alt="image-20221212224345186" style="zoom:67%;" />
<p>slice 对象包含首元素的引用和长度，如上图。字符串 slice range 的索引必须位于有效的 UTF-8 字符边界处，否则会导致 panic。字符串 slice 也可以是 mut 引用。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="结构体"><a class="header" href="#结构体">结构体</a></h2>
<h4 id="定义"><a class="header" href="#定义">定义</a></h4>
<p>类型名使用大驼峰规范。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    active: bool,
    username: String,
    id: u64,
}
<span class="boring">}
</span></code></pre></pre>
<p>每一部分数据称为字段（field）。在结构体中存储引用需要用上生命周期特性。</p>
<p>实例化和访问语法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut u1 = User {
    active: true,
    username: String::from(&quot;Tom&quot;),
    id: 1,
};

let a = u1.active;
u1.id = 8;
<span class="boring">}
</span></code></pre></pre>
<p>要么整体 mut，要么整体不可变。Rust 不允许只让一部分字段可变。</p>
<p>模式匹配和解构：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

let p = Point { x: 0, y: 7 };
let Point { x: a, y: b } = p;
let Point { x, y } = p;		// 简写
if let Point { x: 0, y } = p {}		// 检测值
if let Point { x: 0..=5, y } = p {}	// 检测范围
if let Point { x: v @ 0, y } = p {} // 检测值的同时绑定变量
<span class="boring">}
</span></code></pre></pre>
<h4 id="字段初始化简写"><a class="header" href="#字段初始化简写">字段初始化简写</a></h4>
<p>实例化时，如果作用域内有和字段名同名的变量（常见的情况是函数参数），可以简写：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let username = String::from(&quot;Tom&quot;);
let id = 1;
let u1 = User {
    active: true,
    username,
    id,
};
<span class="boring">}
</span></code></pre></pre>
<p>变量 <code>username</code> 会移动进入结构体示例，<code>id</code> 会拷贝进入。因此在 <code>u1</code> 创建之后 <code>username</code> 不再可用。</p>
<h4 id="结构体更新语法"><a class="header" href="#结构体更新语法">结构体更新语法</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let u1 = User {
    active: true,
    username: String::from(&quot;Tom&quot;),
    id: 1,
};

let u2 = User {
    active: false,
    ..u1
};
<span class="boring">}
</span></code></pre></pre>
<p>用 <code>u1</code> 中的对应字段补足 <code>u2</code> 中缺失的字段。<code>u1.username</code> 被移动，<code>u1.id</code> 被拷贝。被移走的字段不再可用。</p>
<h4 id="元组结构体"><a class="header" href="#元组结构体">元组结构体</a></h4>
<p>元组结构体有整体的名称，但没有字段名。</p>
<pre><pre class="playground"><code class="language-rust">struct Point(i32, i32);

fn main() {
    let origin = Point(0, 0);
    let x = origin.0;
}
</code></pre></pre>
<h4 id="类单元结构体"><a class="header" href="#类单元结构体">类单元结构体</a></h4>
<p>没有字段的结构体。常用在需要在某个类型上实现 trait，但不需要存储数据时。</p>
<pre><pre class="playground"><code class="language-rust">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
</code></pre></pre>
<h2 id="关联函数和方法"><a class="header" href="#关联函数和方法">关联函数和方法</a></h2>
<p>关联函数是在结构体的上下文（<code>impl</code>）中定义的函数，方法是第一个参数为 <code>self</code> 的关联函数，<code>self</code> 代表调用该方法的结构体实例。</p>
<h4 id="定义-1"><a class="header" href="#定义-1">定义</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
    fn square(size: u32) -&gt; Self {
        Self {
            width: size,
            height: size,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在一个 <code>impl</code> 块中，<code>Self</code> 类型是 <code>impl</code> 块类型的别名。<code>&amp;self</code> 是 <code>self: &amp;Self</code> 的缩写，方法可以：</p>
<ul>
<li>仅仅读取对象：<code>&amp;self</code></li>
<li>读写对象：<code>&amp;mut self</code></li>
<li>获取对象的所有权：<code>self</code></li>
</ul>
<p>同一个类型可以定义多个 <code>impl</code> 块。</p>
<h4 id="调用"><a class="header" href="#调用">调用</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>r.area();
Rectangle::square(4);
<span class="boring">}
</span></code></pre></pre>
<p>使用结构体名和 <code>::</code> 来调用关联函数。</p>
<p>自动引用和解引用：当使用 <code>obj.fun()</code> 调用方法时，Rust 会自动为 <code>obj</code> 添加 <code>&amp;</code>, <code>&amp;mut</code>, <code>*</code> 以便使 <code>obj</code> 与方法签名匹配。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="枚举-1"><a class="header" href="#枚举-1">枚举</a></h2>
<h4 id="定义-2"><a class="header" href="#定义-2">定义</a></h4>
<p>结构体代表积类型，枚举代表和类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddrKind {
    V4,
    V6,
}

let a = IpAddrKind::V4;
<span class="boring">}
</span></code></pre></pre>
<p>将数据附加到枚举的成员上：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

let a = Message::Move { x: 1, y: 2 };
let b = Message::Write(String::from(&quot;foo&quot;));
<span class="boring">}
</span></code></pre></pre>
<h4 id="关联函数和方法-1"><a class="header" href="#关联函数和方法-1">关联函数和方法</a></h4>
<p>枚举也可以通过 <code>impl</code> 定义关联函数和方法。</p>
<h4 id="option"><a class="header" href="#option">Option</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}
</span></code></pre></pre>
<p>实例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = Some(5);
let b: Option&lt;String&gt; = None;	// 这里需要声明类型（如果从下文不能推断出的话）
<span class="boring">}
</span></code></pre></pre>
<p>在一些有 Null 的语言中，任何类型的变量都可能为空，极大影响了安全性。Rust 中没有 Null，而是通过 Option 枚举实现类似的功能，避免了空值的泛滥。确保在使用 <code>T</code> 类型的变量时其总是一个有效的值，而在可能出现空值的地方使用 <code>Option&lt;T&gt;</code>，强制要求处理其为空的情况，确保了安全。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="控制流"><a class="header" href="#控制流">控制流</a></h2>
<h4 id="if-表达式"><a class="header" href="#if-表达式"><code>if</code> 表达式</a></h4>
<p>注意 <code>if</code> 是表达式，它可以有返回值。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = if condition {
    println!(&quot;true!&quot;);
    1
} else {
    println!(&quot;false!&quot;);
    0
};
<span class="boring">}
</span></code></pre></pre>
<p>如果有大量的分支，建议使用 <code>match</code>。</p>
<h4 id="loop-表达式"><a class="header" href="#loop-表达式"><code>loop</code> 表达式</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = loop {
    cnt += 1;
    if cnt &gt; 10 {
        break cnt * 2;
    }
};
<span class="boring">}
</span></code></pre></pre>
<p>如果存在嵌套循环，<code>break</code> 和 <code>continue</code> 作用于最内层的循环。可以在循环上指定循环标签，在 <code>break</code> 和 <code>continue</code> 时使用。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 'label: loop {
    break 'label cnt * 2;
};
<span class="boring">}
</span></code></pre></pre>
<h4 id="while-循环"><a class="header" href="#while-循环"><code>while</code> 循环</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while cnt &gt; 0 {
    println!(&quot;{}!&quot;, cnt);
    cnt -= 1;
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="for-循环"><a class="header" href="#for-循环"><code>for</code> 循环</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = [1, 2, 3, 4, 5];
for ele in &amp;a {
    println!(&quot;{ele}&quot;);
}
for ele in &amp;mut a {
    *ele += 10;
}
for ele in a {
    println!(&quot;{ele}&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>根据 <code>in</code> 后的式子，隐式调用了 <code>iter()</code>，<code>iter_mut()</code>，<code>into_iter()</code>，得到迭代器。</p>
<p>获取下标的方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec!['a', 'b', 'c'];

for (index, value) in v.iter().enumerate() {
    println!(&quot;{} is at index {}&quot;, value, index);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="模式匹配-1"><a class="header" href="#模式匹配-1">模式匹配</a></h2>
<h4 id="match-表达式"><a class="header" href="#match-表达式"><code>match</code> 表达式</a></h4>
<p>模式匹配。match 要求必须穷尽所有的情况</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num = match foo {
    Some(x) =&gt; x + 1,
    None =&gt; panic!(),
};
<span class="boring">}
</span></code></pre></pre>
<p>其他细节：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>_ =&gt; println!(&quot;nonzero&quot;),		// 用 _ 忽略匹配到的值
_ =&gt; (),						// 用空元组表示什么也不做
1 | 2 | 3 =&gt; (),				// 匹配多种情况
1..=10 =&gt; (),					// 匹配范围
'a'..='j' =&gt; (),				// 字符范围
v @ 0..=100 =&gt; (),				// @ 指定范围的同时绑定
(a, .., b) =&gt; (),				// .. 忽略若干个量
x if x%2 == 0 =&gt; (),			// 匹配守卫（match guard）
<span class="boring">}
</span></code></pre></pre>
<p>有关结构体和枚举的解构/匹配见 <code>结构体.md</code></p>
<h4 id="if-let-控制流"><a class="header" href="#if-let-控制流"><code>if let</code> 控制流</a></h4>
<p>用于处理只匹配一个模式而忽略其他值的情况：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num = Some(1);

if let Some(x) = num {	// 只匹配 Some，忽略 None
    println!(&quot;num = {}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<p>还可以加 <code>else</code> 分支。</p>
<h4 id="while-let-条件循环"><a class="header" href="#while-let-条件循环"><code>while let</code> 条件循环</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while let Some(a) = args.next() {
    println!(&quot;{}&quot;, a);
}
<span class="boring">}
</span></code></pre></pre>
<p>匹配成功则继续循环，适合从迭代器或其他容器中逐个取出元素</p>
<div style="break-before: page; page-break-before: always;"></div><p>模块系统包括：</p>
<ul>
<li>包（Packages）： Cargo 的一个功能，它允许你构建、测试和分享 crate。</li>
<li>Crates ：一个模块的树形结构，它形成了库或二进制项目。</li>
<li>模块（Modules）和 use： 允许你控制作用域和路径的私有性。</li>
<li>路径（path）：一个命名例如结构体、函数或模块等项的方式</li>
</ul>
<h2 id="crate"><a class="header" href="#crate">Crate</a></h2>
<p>crate 是编译的最小的代码单位。crate 包含多个模块，模块构成树形结构。</p>
<p>crate 有两种形式：二进制项和库。</p>
<ul>
<li>二进制项可以被编译为可执行程序，必须有一个 <code>main</code> 函数</li>
<li>库没有 <code>main</code> 函数，它提供一些函数之类的东西，供其他项目使用</li>
</ul>
<h4 id="包"><a class="header" href="#包">包</a></h4>
<p>包是提供一系列功能的一个或多个 crate。一个包会包含一个 <code>Cargo.toml</code> 文件，阐述如何构建这些 crate。一个包可以包含多个二进制 crate 项和一个可选的 crate 库。</p>
<h4 id="根文件"><a class="header" href="#根文件">根文件</a></h4>
<pre><code class="language-shell">my-project
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p>crate root 是一个源文件，编译器以它为起点，构建 crate。</p>
<ul>
<li><code>src/main.rs</code> 是一个二进制 crate 的根文件，这个 crate 与包同名</li>
<li><code>src/lib.rs</code> （如果有的话）是一个库 crate 的根文件，这个 crate 与包同名</li>
<li>在 <code>src/bin</code> 下放置文件，可以创建更多二进制 crate。每个文件编译成一个独立的 crate</li>
</ul>
<h2 id="模块"><a class="header" href="#模块">模块</a></h2>
<ul>
<li>编译 crate 时，编译器首先在 crate 根文件中寻找需要被编译的代码</li>
<li>在根文件中，可以用 <code>mod</code> 关键字声明模块。例如使用 <code>mod xxx</code> 声明了一个模块，编译器会在这些地方寻找模块代码：
<ul>
<li><code>mod xxx {...}</code> 大括号内的部分（内联）</li>
<li>文件 <code>src/xxx.rs</code></li>
<li>文件 <code>src/xxx/mod.rs</code></li>
</ul>
</li>
<li>在根文件以外的文件中，可以定义子模块，例如在 <code>src/xxx.rs</code> 中定义了 <code>mod yyy</code>，编译器会在这些地方寻找子模块代码：
<ul>
<li><code>mod yyy {...}</code> 大括号内的部分（内联）</li>
<li>文件 <code>src/xxx/yyy.rs</code></li>
<li>文件 <code>src/xxx/yyy/mod.rs</code></li>
</ul>
</li>
</ul>
<p>模块构成树形结构，就像文件系统一样。</p>
<h4 id="访问"><a class="header" href="#访问">访问</a></h4>
<p>在 crate 内的任意位置，可以通过两种方式访问东西：</p>
<ul>
<li>绝对路径 <code>crate::xxx::yyy::something</code>，以 <code>crate</code> 起始</li>
<li>相对路径，从当前模块开始，以 <code>self</code>、<code>super</code> 或模块名开头</li>
</ul>
<h4 id="use"><a class="header" href="#use"><code>use</code></a></h4>
<p>可以使用 <code>use</code> 关键字创建快捷方式，例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::xxx::yyy::something
// 之后可以直接使用 something
<span class="boring">}
</span></code></pre></pre>
<p>通常，<code>use</code> 后的路径使用绝对路径，而且一般精确到模块和类型，但不精确到函数。函数采用 <code>模块::函数()</code> 的方式调用，保留其上的一层模块。</p>
<p>通过嵌套路径可以减少 <code>use</code> 行：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{cmp::Ordering, io};
use std::io::{self, Write};
<span class="boring">}
</span></code></pre></pre>
<p>通过通配符导入所有公有项：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}
</span></code></pre></pre>
<h4 id="as"><a class="header" href="#as"><code>as</code></a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Result;
use std::io::Result as IoResult;
<span class="boring">}
</span></code></pre></pre>
<p>可以使用 <code>as</code> 关键字起别名。常用于命名存在冲突的情况。</p>
<h4 id="重导出"><a class="header" href="#重导出">重导出</a></h4>
<p>使用 <code>use</code> 可以把某个名称导入到当前作用域，但这对上层不可见。使用 <code>pub use</code> 可以使导入的名称对上层可见，就好像此名称就在此作用域内一样。</p>
<p>这使我们可以以一定的层次结构编写库，同时以“扁平”的方式对外呈现。</p>
<h4 id="私有性"><a class="header" href="#私有性">私有性</a></h4>
<p>模块定义了 Rust 的私有性边界。子模块里的所有项，包括子模块本身，默认对其父模块私有（不可见）。要使一个模块公有（可见），需用 <code>pub mod</code> 声明。为了使一个公有模块内的成员公有，在声明前加 <code>pub</code>。父模块中的项总是对子模块公有。</p>
<p>可以使用 <code>pub</code> 使结构体/枚举定义公有。结构体的字段需添加 <code>pub</code> 才会公有，而只要枚举的定义公有，其所有内容都会公有。</p>
<h2 id="示例"><a class="header" href="#示例">示例</a></h2>
<h4 id="backyard"><a class="header" href="#backyard">backyard</a></h4>
<p>一个名为 <code>backyard</code> 的二进制 crate：</p>
<pre><code class="language-shell">backyard
├── Cargo.toml
└── src
	├── main.rs
	├── garden.rs
    └── garden
        └── vegetables.rs
</code></pre>
<p>crate 根文件为 <code>src/main.rs</code>，内容为：</p>
<pre><pre class="playground"><code class="language-rust">use crate::garden::vegetables::Asparagus;

pub mod garden;	// -&gt; garden.rs

fn main() {
    let plant = Asparagus {};
    println!(&quot;I'm growing {:?}!&quot;, plant);
}
</code></pre></pre>
<p><code>src/garden.rs</code> 内容为：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod vegetables;	// -&gt; garden/vegetables.rs
<span class="boring">}
</span></code></pre></pre>
<p><code>src/garden/vegetables.rs</code> 内容为：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct Asparagus {}
<span class="boring">}
</span></code></pre></pre>
<h4 id="restaurant"><a class="header" href="#restaurant">restaurant</a></h4>
<p>一个名为 <code>restaurant</code> 的库 crate：</p>
<pre><code class="language-shell">restaurant
├── Cargo.toml
└── src
    └── lib.rs
</code></pre>
<p>模块树：</p>
<pre><code class="language-shell">crate
 ├── front_of_house
 │   ├── hosting
 │   └── serving
 └── back_of_house
</code></pre>
<p>根文件 <code>src/lib.rs</code> 内容为：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/* 绝对路径和相对路径访问 */
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
    mod serving {
    }
}

pub fn eat_at_restaurant() {
    crate::front_of_house::hosting::add_to_waitlist();
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">}
</span></code></pre></pre>
<p>这里 <code>front_of_house</code> 不需要加 <code>pub</code>，因为 <code>crate::front_of_house</code> 和 <code>crate::eat_at_restaurant</code> 在同一层级下，互相可见。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/* super 的使用 */
fn serve_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();	// 调用上层函数
    }
    fn cook_order() {}
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/* 结构体的私有性 */
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from(&quot;peaches&quot;),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // 在夏天订购一个黑麦土司作为早餐
    let mut meal = back_of_house::Breakfast::summer(&quot;Rye&quot;);
    // 改变主意更换想要面包的类型
    meal.toast = String::from(&quot;Wheat&quot;);
    println!(&quot;I'd like {} toast please&quot;, meal.toast);

    // 如果取消下一行的注释代码不能编译；
    // 不允许查看或修改早餐附带的季节水果
    // meal.seasonal_fruit = String::from(&quot;blueberries&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/* 枚举的私有性 */
mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="使用外部包"><a class="header" href="#使用外部包">使用外部包</a></h2>
<p>为了使用外部包 <code>rand</code>，在 <code>Cargo.toml</code> 中加入</p>
<pre><code class="language-toml">rand = &quot;0.8.3&quot;
</code></pre>
<p>于是 cargo 从 crates.io 下载 <code>rand</code> 及其依赖，接下来可以将其导入：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rand::Rng;
<span class="boring">}
</span></code></pre></pre>
<p>标准库对于项目来说也是外部包，也需要通过 <code>use</code> 导入，不过不需要修改 <code>Cargo.toml</code></p>
<h2 id="将-crate-发布到-cratesio"><a class="header" href="#将-crate-发布到-cratesio">将 Crate 发布到 crates.io</a></h2>
<p>具体操作参考 the book</p>
<h2 id="工作空间"><a class="header" href="#工作空间">工作空间</a></h2>
<p>用于管理多个协同开发的包，参考 the book</p>
<div style="break-before: page; page-break-before: always;"></div><p>字符串，包括内置类型 <code>str</code> 和 标准库类型 <code>String</code>。它们都是 UTF-8 编码的。</p>
<h2 id="字符串字面值"><a class="header" href="#字符串字面值">字符串字面值</a></h2>
<p>字符串字面值是静态的，也就是在整个程序运行期间一直存在。其类型为 <code>&amp;str</code>，而且不能是 mut 引用。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello&quot;;	// &amp;str
let sl = &amp;s[..];	// &amp;str
let ss = &amp;s;		// &amp;&amp;str
<span class="boring">}
</span></code></pre></pre>
<h4 id="deref-强制转换"><a class="header" href="#deref-强制转换">Deref 强制转换</a></h4>
<p><code>&amp;String</code> 可以自动转换成 <code>&amp;str</code>。因此函数参数建议使用 <code>&amp;str</code> 替代 <code>&amp;String</code>，这样可以扩大能接收的参数的范围。</p>
<h4 id="原始字符串"><a class="header" href="#原始字符串">原始字符串</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = r&quot;\n&quot;;		// \n
let s = r#&quot;ab&quot;cd&quot;#;	// ab&quot;cd
<span class="boring">}
</span></code></pre></pre>
<p><code>#</code> 可以加任意多对。</p>
<h2 id="string"><a class="header" href="#string">String</a></h2>
<h4 id="创建"><a class="header" href="#创建">创建</a></h4>
<ol>
<li><code>new</code> 函数创建空字符串</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::new();
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li>实现了 <code>Display</code> trait 的类型可以使用 <code>to_string</code> 方法创建字符串，例如 <code>str</code>：</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hi&quot;.to_string();
<span class="boring">}
</span></code></pre></pre>
<ol start="3">
<li><code>from</code> 函数从字面值创建</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hi&quot;);
<span class="boring">}
</span></code></pre></pre>
<h4 id="更新"><a class="header" href="#更新">更新</a></h4>
<ol>
<li>使用 <code>push_str</code> 方法附加</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>s.push_str(&quot;bar&quot;);
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li><code>push</code> 方法附加单个字符（<code>char</code>）</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>s.push('H');
<span class="boring">}
</span></code></pre></pre>
<ol start="3">
<li>使用 <code>+</code> 运算符</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// + 的函数签名为：
fn add(self, other: &amp;str) -&gt; String

let s1 = &quot;foo&quot;.to_string();
let s2 = &quot;bar&quot;.to_string();
let s = s1 + &quot;-&quot; + &amp;s2;		// s1 不再可用，s2 仍有效
<span class="boring">}
</span></code></pre></pre>
<ol start="4">
<li><code>format!</code> 宏</li>
</ol>
<p><code>format!</code> 宏的工作原理与 <code>print!</code> 相同。<code>format!</code> 取参数的引用，不获取所有权。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = &quot;foo&quot;.to_string();
let s2 = &quot;bar&quot;.to_string();
let s = format!(&quot;{}-{}&quot;, s1, s2);	// s1 和 s2 仍有效
<span class="boring">}
</span></code></pre></pre>
<h4 id="索引"><a class="header" href="#索引">索引</a></h4>
<p>String 类型不支持使用下标来索引。因为 String 事实上是对 <code>Vec&lt;u8&gt;</code> 的封装，而 UTF-8 字符所占的字节数可变。按字节索引会产生严重的错误，而要按字符索引需要 <code>O(n)</code> 的时间，不符合索引操作通常的期望值 <code>O(1)</code>。</p>
<p>虽然不允许以 <code>s[n]</code> 的方式索引，但可以以 <code>&amp;s[n..m]</code> 的方式获取 slice。slice 边界必须在合法的 UTF-8 字符边界处，否则会导致 panic。</p>
<h4 id="遍历"><a class="header" href="#遍历">遍历</a></h4>
<ol>
<li><code>chars</code> 方法返回 Unicode 标量值（<code>char</code>）的迭代器</li>
<li><code>bytes</code> 方法返回每一个字节（<code>u8</code>）的迭代器</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = &quot;乐&quot;.to_string();
for i in s1.chars() {
    println!(&quot;{i}&quot;);	// -&gt; 乐
}
for i in s1.bytes() {
    println!(&quot;{i}&quot;);	// -&gt; 228, 185, 144
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><code>Vec&lt;T&gt;</code> 允许存储多个相同类型的值，且在内存（堆）上顺序排列。</p>
<h4 id="创建-1"><a class="header" href="#创建-1">创建</a></h4>
<ol>
<li><code>new</code> 函数创建空 Vec</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1: Vec&lt;String&gt; = Vec::new();
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li><code>vec!</code> 宏创建</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v2 = vec!['b', 'a', 'c'];	// Vec&lt;char&gt;
<span class="boring">}
</span></code></pre></pre>
<h4 id="更新-1"><a class="header" href="#更新-1">更新</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = Vec::new();
v.push(1);	// pub fn push(&amp;mut self, value: T)
v.pop();	// pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt;
<span class="boring">}
</span></code></pre></pre>
<p>还有很多方法，可以查API文档</p>
<h4 id="所有权-1"><a class="header" href="#所有权-1">所有权</a></h4>
<p><code>Copy</code> 类型的变量会被拷贝进入 Vec。非 <code>Copy</code> 类型的变量会被移动进入 Vec，其所有权交给 Vec。</p>
<p>如果将值的引用插入 Vec，这些值本身将不会被移动进 Vec。但是这些引用指向的值必须至少在 Vec 有效时也是有效的。生命周期与引用有效性部分将会更多地讨论这个问题。</p>
<h4 id="访问-1"><a class="header" href="#访问-1">访问</a></h4>
<p>常用的两种方式：</p>
<ol>
<li>通过下标获取引用 <code>&amp;v[n]</code>，越界会导致 <code>panic</code></li>
<li>通过 <code>get(n)</code> 方法获取引用，会得到 <code>Option</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![String::from(&quot;hi&quot;)];
let s1 = &amp;v[0];				// &amp;mut 得到可变引用
let s2 = match v.get(0) {	// get_mut 得到可变引用
    Some(s) =&gt; s,
    None =&gt; panic!(),
};
<span class="boring">}
</span></code></pre></pre>
<p>注意遵循借用规则，下面的代码不能通过编译：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![1, 2, 3];
let i = &amp;v[0];		// 不可变引用
v.push(4);			// 可变引用
println!(&quot;{i}&quot;);	// 添加元素可能导致内存重新分配，使原引用失效
<span class="boring">}
</span></code></pre></pre>
<p>另外，也可以用 <code>v[n]</code> 的方式直接访问其中元素，但不允许将其中元素移动出来。</p>
<h4 id="slice-1"><a class="header" href="#slice-1">slice</a></h4>
<p>Vec 可以转换为 slice</p>
<h4 id="遍历-1"><a class="header" href="#遍历-1">遍历</a></h4>
<ol>
<li>使用 <code>for i in &amp;v</code> 得到不可变引用</li>
<li>使用 <code>for i in &amp;mut v</code> 得到可变引用</li>
<li>使用 <code>for i in v</code> 隐式调用 <code>into_iter()</code>，会导致移动</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><p><code>HashMap&lt;K, V&gt;</code> 以键值对的形式将数据存储在堆上。</p>
<h4 id="创建-2"><a class="header" href="#创建-2">创建</a></h4>
<p><code>HashMap</code> 没有被 prelude 自动引用，需要 <code>use</code> 导入</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}
</span></code></pre></pre>
<ol>
<li><code>new</code> 方法创建</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut m = HashMap::new();
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li>在键值对元组的 vector 上使用迭代器和 <code>collect</code> 方法</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let teams = vec![&quot;Blue&quot;.to_string(), &quot;Yellow&quot;.to_string()];
let initial_scores = vec![10, 50];

let mut scores: HashMap&lt;_, _&gt; = teams.into_iter().zip(initial_scores.into_iter()).collect();
<span class="boring">}
</span></code></pre></pre>
<p><code>collect</code> 可以输出很多种数据结构，因此 <code>HashMap&lt;_, _&gt;</code> 类型注解是必须的，但是键值对的类型可以用下划线占位，编译器能推断出。</p>
<h4 id="更新-2"><a class="header" href="#更新-2">更新</a></h4>
<ol>
<li><code>insert</code> 插入键值对，如果已存在则覆盖</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>m.insert(&quot;hi&quot;.to_string(), 10);
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li>只在不存在时插入</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>m.entry(&quot;hi&quot;.to_string()).or_insert(10);
<span class="boring">}
</span></code></pre></pre>
<p><code>entry</code> 方法返回 <code>Entry</code> 枚举，表示可能存在的值，其上的 <code>or_insert</code> 方法在值不存在时将参数作为值插入，并返回值的可变引用</p>
<ol start="3">
<li>根据旧值更新一个值</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/* 统计单词个数 */
let text = &quot;hello world wonderful world&quot;;
let mut map = HashMap::new();
for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="访问-2"><a class="header" href="#访问-2">访问</a></h4>
<p>使用 <code>get</code> 方法，返回 <code>Option&lt;V&gt;</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = m.get(&amp;String::from(&quot;hi&quot;));
<span class="boring">}
</span></code></pre></pre>
<h4 id="遍历-2"><a class="header" href="#遍历-2">遍历</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for (k, v) in &amp;m {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>使用 <code>&amp;mut m</code> 后，仅 <code>v</code> 会是可变引用。直接使用 <code>m</code> 会导致 <code>m</code> 被移动走。遍历的顺序是随机的。</p>
<div style="break-before: page; page-break-before: always;"></div><p>Rust 没有异常系统。Rust 将错误分为两类：<strong>可恢复的</strong>（<em>recoverable</em>）和 <strong>不可恢复的</strong>（<em>unrecoverable</em>）。
可恢复的错误例如文件未找到。不可恢复的错误如下标越界，这往往是出现bug的征兆。
Rust 用 <code>Result&lt;T, E&gt;</code> 类型处理可恢复的错误，用 <code>panic!</code> 宏在遇到不可恢复的错误时停止执行。</p>
<h2 id="panic-1"><a class="header" href="#panic-1"><code>panic!</code></a></h2>
<p>出现 <code>panic!</code> 时，程序默认会进行<strong>展开</strong>（<em>unwinding</em>），即回溯和清理栈上的数据。另外也可以选择直接终止（abort）程序。在 <code>Cargo.toml</code> 的 <code>[profile]</code> 部分添加 <code>panic = 'about'</code> 即可采用终止方式。</p>
<p>设置 <code>RUST_BACKTRACE=1</code> 环境变量后即可查看发生 panic 的函数调用回溯。</p>
<h2 id="result"><a class="header" href="#result"><code>Result</code></a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
	Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p>可以使用 match 来处理，例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = match File::open(&quot;hello.txt&quot;) {
    Ok(f) =&gt; f,
    Err(e) =&gt; panic!(&quot;{:?}&quot;, e),
};
<span class="boring">}
</span></code></pre></pre>
<p>可以用 <code>Result</code> 上的 <code>unwrap</code> 函数处理，如果 <code>Result</code> 是 <code>Ok</code>，<code>unwrap</code> 返回其中的值，否则调用 <code>panic!</code>。<code>expect</code> 函数与 <code>unwrap</code> 类似，不过可以指定报错信息：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut f = File::open(&quot;hello.txt&quot;).unwrap();
let mut f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);
<span class="boring">}
</span></code></pre></pre>
<h4 id="错误传播"><a class="header" href="#错误传播">错误传播</a></h4>
<p>在函数中遇到错误，将其传递给上层调用者是一种常见的操作。一种直观的写法是使用 <code>match</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_file_into_string() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = match File::open(&quot;hello.txt&quot;) {
        Ok(f) =&gt; f,
        Err(e) =&gt; return Err(e),
    };
    let mut s = String::new();
    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; return Err(e),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>为了减少样板代码，可以使用 <code>?</code> 运算符，其作用与上面的 <code>match</code> 相同：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_file_into_string() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<p>还可以通过链式调用，使代码更简洁：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_file_into_string() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();
    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;
    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<p>另外，<code>?</code> 运算符也可以用在 <code>Option</code> 上。</p>
<h4 id="main-函数"><a class="header" href="#main-函数"><code>main</code> 函数</a></h4>
<p><code>main</code> 函数的返回值可以是 <code>Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt;</code>，这就允许 <code>main</code> 函数返回错误。可执行程序最终会向操作系统返回合适的整数。</p>
<div style="break-before: page; page-break-before: always;"></div><h4 id="泛型函数"><a class="header" href="#泛型函数">泛型函数</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fun&lt;T&gt;(v: T) -&gt; T {
    v
}
<span class="boring">}
</span></code></pre></pre>
<p>注意：泛型参数通常不能在返回值上使用，因为泛型参数表示这是一个可以由调用者决定的类型，而返回值的类型一般可以从函数体推断出，例如这就是一个非法的定义：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fun&lt;T&gt;() -&gt; T {
    1
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="泛型结构体枚举"><a class="header" href="#泛型结构体枚举">泛型结构体/枚举</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}

struct Point&lt;T&gt; {
    x: T,
    y: T,
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="方法中的泛型"><a class="header" href="#方法中的泛型">方法中的泛型</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Point&lt;T&gt; {			// 这里可以添加 trait bound
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
    
    fn fun&lt;U&gt;(&amp;self) -&gt; U {		// 追加泛型参数
        todo!()
    }
}

// 也可以针对具体类型定义
impl Point&lt;f32&gt; {
    fn distance(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>泛型不会带来性能损失，因为 Rust 采用一种称为“单态化”的技术将泛型转化成具体类型来处理，函数会静态分发。也因此泛型类型参数一次只能替代一个具体类型。</p>
<div style="break-before: page; page-break-before: always;"></div><h4 id="生命周期"><a class="header" href="#生命周期">生命周期</a></h4>
<p>生命周期是一种泛型。声明周期代表变量/引用有效的范围。例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r;
{
    let x = 5;
    r = &amp;x;
}
println!(&quot;{}&quot;, r);
<span class="boring">}
</span></code></pre></pre>
<p>变量 <code>x</code> 的生命周期（可以用 <code>'a</code> 表示）即从其声明到右大括号。Rust 借用检查器要求引用的生命周期不大于对应变量的生命周期。因此这段代码不能通过编译。</p>
<h4 id="函数中的生命周期注解"><a class="header" href="#函数中的生命周期注解">函数中的生命周期注解</a></h4>
<p>从两个字符串中找出较长的一个的函数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longer&lt;'a&gt;(s1: &amp;'a str, s2: &amp;'a str) -&gt; &amp;'a str {
    if s1.len() &gt; s2.len() {
        s1
    } else {
        s2
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这里使用生命周期注解 <code>'a</code>，表明返回的引用依赖于（指向）参数 <code>s1</code> 和 <code>s2</code>，因此返回的引用的生命周期为 <code>s1</code> 和 <code>s2</code> 的生命周期重叠的部分</p>
<p>函数或方法的参数的生命周期被称为输入生命周期，而返回值的生命周期被称为输出生命周期。在一些情况下可以省略生命周期标注：</p>
<ol>
<li>函数仅有一个输入生命周期，则所有输出生命周期与其相同</li>
<li>函数是方法，则所有输出生命周期默认与 <code>self</code> 相同</li>
</ol>
<h4 id="结构体中的生命周期注解"><a class="header" href="#结构体中的生命周期注解">结构体中的生命周期注解</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Fun&lt;'a&gt; {
    s: &amp;'a str,
    i: usize,
}

impl&lt;'a&gt; Fun&lt;'a&gt; {
    fn new(s: &amp;str) -&gt; Fun {
        Fun { s, i: s.len() }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Fun</code> 含有对其他对象的引用，其生命周期依赖于其他对象，因此需要生命周期注解。<code>Fun</code>  对象的生命周期不能比借来的对象 <code>s</code> 更长</p>
<h4 id="静态生命周期"><a class="header" href="#静态生命周期">静态生命周期</a></h4>
<p>字符串字面量具有静态生命周期</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="trait"><a class="header" href="#trait">Trait</a></h2>
<h4 id="定义-3"><a class="header" href="#定义-3">定义</a></h4>
<p>trait 类似其他编程语言中的接口</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Show {
    fn show(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Comparable {
    fn bigger_than(&amp;self, b: &amp;Self) -&gt; bool;	// trait impl 到什么类型上，Self 就是什么类型
}
<span class="boring">}
</span></code></pre></pre>
<p>可以定义方法的默认实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Show {
    fn show(&amp;self) -&gt; String {
        String::new()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>可以在一个 trait 中定义多个方法，它们之间可以互相调用。</p>
<h4 id="为类型实现-trait"><a class="header" href="#为类型实现-trait">为类型实现 trait</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

impl Show for Point {
    fn show(&amp;self) -&gt; String {
        format!(&quot;({}, {})&quot;, self.x, self.y)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>为类型实现 trait 时，要么类型，要么 trait 要位于本地作用域内。不允许为外部类型实现外部 trait，例如在自己的程序中为标准库类型 <code>Vec&lt;T&gt;</code> 实现标准库 trait <code>Display</code>。这个限制称为“相干性”或“孤儿规则”。</p>
<p>甚至可以对泛型实现 trait。例如，标准库对所有 Display 的类型实现了 ToString</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Display&gt; ToString for T {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: PartialOrd&gt; Comparable for T {
    fn bigger_than(&amp;self, b: &amp;Self) -&gt; bool {
        self &gt; b
    }
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="trait-参数返回值"><a class="header" href="#trait-参数返回值">trait 参数/返回值</a></h4>
<p>用 trait 限定函数泛型参数的类型，以便于在函数中调用 trait 提供的方法。有两种语法：</p>
<ol>
<li><code>impl Trait</code> 语法</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fun(item: &amp;impl Show) {
    println!(&quot;{}&quot;, item.show());
}
<span class="boring">}
</span></code></pre></pre>
<p>也可以在返回值上使用</p>
<ol start="2">
<li><code>trait</code> bound 语法</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fun&lt;T: Show&gt;(item: &amp;T) {
    println!(&quot;{}&quot;, item.show());
}
<span class="boring">}
</span></code></pre></pre>
<p>注意：这种语法通常不能在返回值上使用，原因见 <code>泛型.md</code></p>
<p>指定多个 trait 时，用加号连接：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fun(item: &amp;(impl Show + Display))
fn fun&lt;T: Show + Display&gt;(item: &amp;T)
<span class="boring">}
</span></code></pre></pre>
<p>另外，可以用 <code>where</code> 语法避免过长的签名</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
...
<span class="boring">}
</span></code></pre></pre>
<p>注意：这里是通过“单态化”实现的，函数静态分发，泛型类型参数一次只能替代一个具体类型。</p>
<hr />
<h2 id="高级特性-2"><a class="header" href="#高级特性-2">高级特性</a></h2>
<h4 id="关联类型"><a class="header" href="#关联类型">关联类型</a></h4>
<p>关联类型是一个占位符类型，例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>关联类型与泛型参数的区别在于：trait 有泛型参数时，在同一个类型上，可以多次以不同泛型类型实现这个 trait，且在调用 trait 方法的时候也不得不加上类型注解。</p>
<h4 id="运算符重载"><a class="header" href="#运算符重载">运算符重载</a></h4>
<p>可以重载 <code>std::ops</code> 中列出的运算符，例如加法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Add for Point {
    type Output = Point;
    fn add(self, rhs: Self) -&gt; Self::Output {
        Self {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="默认泛型类型参数"><a class="header" href="#默认泛型类型参数">默认泛型类型参数</a></h4>
<p>定义 trait 时可以为泛型参数指定默认类型，例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Add&lt;Rhs = Self&gt; {		// 默认情况下，加法运算实现在两个相同的类型上
    type Output;
    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="完全限定语法和消歧义"><a class="header" href="#完全限定语法和消歧义">完全限定语法和消歧义</a></h4>
<ol>
<li>如果 trait 和类型上的方法重名，可以通过以下语法消歧义（也可以使用后面的完全限定语法）：</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {..}

impl Wizard for Human {..}

impl Human {
    fn fly(&amp;self) {..}
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let person = Human;
Pilot::fly(&amp;person);
Wizard::fly(&amp;person);
person.fly();
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li>如果 trait 和类型上的关联函数重名，可以使用完全限定语法：</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {..}
}

impl Animal for Dog {..}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Dog::baby_name()
&lt;Dog as Animal&gt;::baby_name()
<span class="boring">}
</span></code></pre></pre>
<h4 id="父-trait"><a class="header" href="#父-trait">父 trait</a></h4>
<p>可以定义基于其他 trait 的 trait。例如定义一个 <code>OutlinePrint</code> trait，基于 <code>Display</code> trait，提供 <code>outline_print</code> 方法，在打印值的前后加上星号，那么只有在实现了 <code>Display</code> 的类型上才能实现 <code>OutlinePrint</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait OutlinePrint: Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        println!(&quot;* {} *&quot;, output);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="newtype-模式"><a class="header" href="#newtype-模式">newtype 模式</a></h4>
<p>为了在外部类型上实现外部 trait，可以使用一种叫 newtype 模式的设计方法。即用元组结构体包装目标类型，然后在新类型上实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Wrapper(Vec&lt;String&gt;);
impl fmt::Display for Wrapper {..}
<span class="boring">}
</span></code></pre></pre>
<p>这样做的缺点是新类型不能直接使用原类型上的各种方法。可以考虑使用 <code>Deref</code> trait 解决这个问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="测试模块和测试函数"><a class="header" href="#测试模块和测试函数">测试模块和测试函数</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>调用 <code>cargo test</code> 以运行所有测试函数。可以添加任意多的测试模块和测试函数</p>
<h4 id="测试常用宏-1"><a class="header" href="#测试常用宏-1">测试常用宏</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert!(true);
assert_eq!(2 + 2, 4);
assert_ne!(2 + 2, 5);
<span class="boring">}
</span></code></pre></pre>
<p>这几个宏可以提供更多的参数，将作为 panic 时的信息打印出来。</p>
<p><code>assert_eq!</code> 和 <code>assert_ne!</code> 事实上使用了 <code>==</code> 和 <code>!=</code>，并在失败时打印其值。因此被测试的值必须实现了 <code>PartialEq</code> 和 <code>Debug</code> trait。这两个 trait 都是可派生的 trait，因此可以直接在类型上添加 <code>#[derive(PartialEq, Debug)]</code> 注解。</p>
<h4 id="should_panic-注解"><a class="header" href="#should_panic-注解"><code>should_panic</code> 注解</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[should_panic]
fn it_works() {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>添加 <code>should_panic</code> 注解，表明一个测试应当引发 panic。另外为了避免意外的 panic 使测试通过，可以添加期望的 panic 信息</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[should_panic(expected = &quot;foobar&quot;)]	// 实际 panic 信息需要包含 &quot;foobar&quot;
<span class="boring">}
</span></code></pre></pre>
<h4 id="resultt-e"><a class="header" href="#resultt-e"><code>Result&lt;T, E&gt;</code></a></h4>
<p>测试函数可以返回 <code>Result</code> 作为测试结果：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn it_works() -&gt; Result&lt;(), String&gt; {
    if 2 + 2 == 4 {
        Ok(())
    } else {
        Err(String::from(&quot;two plus two does not equal four&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="cargo-test"><a class="header" href="#cargo-test"><code>cargo test</code></a></h2>
<ol>
<li>向 <code>cargo test</code>  传递参数，例如：<code>cargo test --help</code></li>
<li>向 <code>cargo test</code>  生成的测试程序传递参数，放在 <code>--</code> 分隔符后，例如：<code>cargo test -- --help</code></li>
</ol>
<h4 id="并行控制"><a class="header" href="#并行控制">并行控制</a></h4>
<p>测试程序默认并行运行各个测试函数。可以通过参数设置并行线程数：</p>
<pre><code class="language-shell">cargo test -- --test-threads=1
</code></pre>
<h4 id="输出控制"><a class="header" href="#输出控制">输出控制</a></h4>
<p>测试程序默认屏蔽测试函数的任何标准输出。可以通过参数允许输出：</p>
<pre><code class="language-shell">cargo test -- --show-output
</code></pre>
<h4 id="部分测试"><a class="header" href="#部分测试">部分测试</a></h4>
<p>默认情况下会运行全部的测试函数。可以通过测试模块名和测试函数名指定运行一部分测试：</p>
<pre><code class="language-shell">cargo test my_test1
</code></pre>
<h4 id="忽略部分测试"><a class="header" href="#忽略部分测试">忽略部分测试</a></h4>
<p>可以给（非常耗时的）测试函数添加 <code>ignore</code> 属性，默认排除他们</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[ignore]
fn it_works() {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-shell">cargo test						# 运行没被忽略的测试
cargo test -- --ignored			# 运行被忽略的测试
cargo test -- --include-ignored	# 运行全部测试
</code></pre>
<h2 id="测试的组织结构"><a class="header" href="#测试的组织结构">测试的组织结构</a></h2>
<p>测试通常分为两类：</p>
<ol>
<li>单元测试：更小而更集中，一次测试一个模块，或私有接口</li>
<li>集成测试：就像外部代码一样，只测试公有接口</li>
</ol>
<h4 id="单元测试"><a class="header" href="#单元测试">单元测试</a></h4>
<p>单元测试的方法即上面所述的，创建测试模块和测试函数。单元测试与被测试的代码放在相同文件中。</p>
<h4 id="集成测试"><a class="header" href="#集成测试">集成测试</a></h4>
<p>集成测试对于被测试的库来说完全是外部的。为了创建继承测试，需要在项目根目录下创建一个 <code>tests</code> 目录，与 <code>src</code> 同级。可以在这个目录下创建任意多的测试文件，每个测试文件会被当作一个 crate 来编译。下面是一个集成测试文件的例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
<span class="boring">}
</span></code></pre></pre>
<p>可以在 <code>tests</code> 目录下创建目录，以创建可以被集成测试使用的子模块</p>
<h4 id="二进制-crate-的集成测试"><a class="header" href="#二进制-crate-的集成测试">二进制 crate 的集成测试</a></h4>
<p>二进制 crate 通常没有暴露的接口，无法进行集成测试。因此二进制 crate 往往采用这样的结构：在一个包内包含一个库 crate 和一个二进制 crate。对库 crate 进行集成测试，二进制 crate 的 <code>src/main.rs</code> 调用库的功能，其自身尽可能简单。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="闭包"><a class="header" href="#闭包">闭包</a></h2>
<h4 id="定义-4"><a class="header" href="#定义-4">定义</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }	// 函数
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };	// 闭包
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
<span class="boring">}
</span></code></pre></pre>
<p>闭包一般不需要注明参数和返回值类型，编译器会自动推断。如果闭包函数体只有一行，可以不加大括号</p>
<p>与函数类似，允许在参数位置上使用模式匹配</p>
<h4 id="捕获"><a class="header" href="#捕获">捕获</a></h4>
<p>闭包可以捕获其所在环境中的变量。有三种捕获形式：</p>
<ol>
<li>获取不可变引用</li>
<li>获取可变引用</li>
<li>获取所有权</li>
</ol>
<p>编译器会根据闭包内的情况自动分析每个变量的捕获形式。在参数列表前添加 <code>move</code> 关键字可以强制获取所有权</p>
<h4 id="类型和-trait"><a class="header" href="#类型和-trait">类型和 trait</a></h4>
<p>每个闭包都具有独有的类型，即使他们的签名一样，类型也不同。闭包（包括普通函数）都实现了 <code>Fn</code> 系列的 trait。<code>Fn</code> 系列的 trait 包括 <code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>。</p>
<ol>
<li>如果闭包以获取所有权的方式捕获了环境中的值，则其只能被调用一次，实现 <code>FnOnce</code>。</li>
<li>如果闭包获取可变引用，则其实现 <code>FnMut</code> 和 <code>FnOnce</code>。</li>
<li>如果闭包获取不可变引用或者不捕获变量，则其实现 <code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>。</li>
<li>如果闭包没有捕获任何变量，则其类型可以转为函数指针 <code>fn</code>，这样的闭包之间可以有相同的类型</li>
</ol>
<p>注意：<code>move</code> 关键字不会影响闭包实现了什么 <code>trait</code></p>
<p><code>Fn</code> 系列的 trait 带有泛型参数，写法比较特别，例如 <code>Fn(i32) -&gt; i32</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn exe&lt;T&gt;(f: T, x: i32) -&gt; i32
where
    T: Fn(i32) -&gt; i32,
{
    f(x)
}
<span class="boring">}
</span></code></pre></pre>
<hr />
<h2 id="高级特性-3"><a class="header" href="#高级特性-3">高级特性</a></h2>
<h4 id="返回闭包"><a class="header" href="#返回闭包">返回闭包</a></h4>
<ol>
<li>直接返回闭包</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo1(a: i32) -&gt; impl Fn(i32) -&gt; i32 {
    move |x| x + a
}

fn foo2(b: bool) -&gt; impl Fn(i32) -&gt; i32 {	// 也可以换成 fn(i32) -&gt; i32
    if b {
        |x| x + 1	// 没有捕获变量，可以转为函数指针，因此可以在不同的分支里返回不同的闭包
    } else {
        |x| x + 2
    }
}
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li>使用 trait 对象</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="迭代器"><a class="header" href="#迭代器">迭代器</a></h2>
<p>迭代器都实现了 <code>Iterator</code> trait，这个 trait 大致上为：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;	// trait 的关联类型
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>注意迭代器一般需要是 mut 的才可正常使用。<code>next</code> 方法会“消费”迭代器中的内容。
迭代器是惰性的。Rust 提供零成本抽象，即迭代器的性能与普通手写循环相同，甚至更快。</p>
<h4 id="创建迭代器"><a class="header" href="#创建迭代器">创建迭代器</a></h4>
<p>创建迭代器的三种方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![1, 2, 3, 5];
let mut i1 = v.iter(); 		// 获取 &amp;self			next 得到 Option&lt;&amp;i32&gt;
let mut i2 = v.iter_mut(); 	// 获取 &amp;mut self		next 得到 Option&lt;&amp;mut i32&gt;
let mut i3 = v.into_iter(); // 获取 self			next 得到 Option&lt;i32&gt;
<span class="boring">}
</span></code></pre></pre>
<h4 id="for-循环-1"><a class="header" href="#for-循环-1"><code>for</code> 循环</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in &amp;v
for i in &amp;mut v
for i in v
<span class="boring">}
</span></code></pre></pre>
<p>对应上面的三种创建迭代器方法</p>
<h4 id="消费适配器"><a class="header" href="#消费适配器">消费适配器</a></h4>
<p>迭代器上有一类基于 <code>next</code> 的方法，称为消费适配器。例如 <code>sum()</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sum: i32 = vec![1, 2, 3].iter().sum();
<span class="boring">}
</span></code></pre></pre>
<h4 id="迭代器适配器"><a class="header" href="#迭代器适配器">迭代器适配器</a></h4>
<p>迭代器上有一类方法，可以将迭代器转化为另一个迭代器，称为迭代器适配器。例如 <code>map()</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = vec![1, 2, 3].into_iter().map(|x| x + 1);
<span class="boring">}
</span></code></pre></pre>
<p>例如 <code>filter()</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let target = 10;
let a = vec![10, 8, 23].into_iter().filter(|x| *x &gt; target);
<span class="boring">}
</span></code></pre></pre>
<p><code>zip()</code>：把两个迭代器合并成一个迭代器，每个元素是元组 <code>(a,b)</code> 形式</p>
<h4 id="自定义迭代器"><a class="header" href="#自定义迭代器">自定义迭代器</a></h4>
<p>可以把 <code>Iterator</code> trait 实现到自定义的类型上，只需要指定关联类型、实现 <code>next()</code> 方法即可。这样就可以创建自定义的迭代器。</p>
<h4 id="range"><a class="header" href="#range">Range</a></h4>
<p>一类常用的迭代器</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut r1 = 0..10;		// 0,1,..,9
let mut r2 = 0..=10;	// 0,1,..,10
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>指针除了引用数据以外没有其他功能。智能指针是一类数据结构，他们的表现类似指针，但是拥有额外的元数据和功能。
在 Rust 中，普通引用（指针）和智能指针的另一个区别是，引用是一类只借用数据的指针，而智能指针通常拥有他们指向的数据。
智能指针区别于常规结构体的特性在于其实现了 <code>Deref</code> 和 <code>Drop</code> trait。Rust 中的智能指针例如 <code>String</code> （<code>str</code> 的智能指针）和 <code>Vec&lt;T&gt;</code>（<code>[T]</code> 的智能指针）。</p>
<h2 id="boxt"><a class="header" href="#boxt"><code>Box&lt;T&gt;</code></a></h2>
<p>最基本的智能指针，允许将值放在堆上而不是栈上。栈上只存放指针。常用于：</p>
<ul>
<li>当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候</li>
<li>当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候</li>
<li>当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候</li>
</ul>
<p>可以通过 <code>Box&lt;T&gt;</code> 得到指向对象的可变/不可变引用。当 <code>Box</code> 离开作用域时，将释放其自身和其指向的对象。</p>
<h4 id="递归类型"><a class="header" href="#递归类型">递归类型</a></h4>
<p>Rust 中需要借助 <code>Box&lt;T&gt;</code> 才能创建递归类型。例如一个链表：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

let l = Cons(1, Box::new(Cons(2, Box::new(Nil))));
<span class="boring">}
</span></code></pre></pre>
<h2 id="deref-trait"><a class="header" href="#deref-trait"><code>Deref</code> trait</a></h2>
<p>智能指针需要实现的 trait，它重载了解引用运算符，使得智能指针可以像普通指针一样使用</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Deref {
    type Target: ?Sized;
    fn deref(&amp;self) -&gt; &amp;Self::Target;	// 注意这里返回的是引用，为了避免将所有权移动出去
}
<span class="boring">}
</span></code></pre></pre>
<p>对一个实现 <code>Deref</code> 的对象 <code>b</code> 使用解引用运算符时，会发生这样的替换：<code>*b</code> 替换为 <code>*(b.deref())</code>。注意外面仍有一个解引用运算符，因为 <code>deref()</code> 返回的是目标对象的引用。</p>
<blockquote>
<p>与其叫 <code>deref</code>，不如叫 <code>desmart</code>。因为这个函数把智能指针转换成普通指针（引用）</p>
</blockquote>
<h4 id="deref-强制转换-1"><a class="header" href="#deref-强制转换-1"><code>Deref</code> 强制转换</a></h4>
<p>Rust 会在实现了 <code>Deref</code> trait 的类型上自动调用任意次的 <code>deref()</code>，以使类型匹配：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fun(s: &amp;str) {
    todo!()
}

let b = Box::new(String::new());
fun(&amp;b);	// &amp;Box&lt;String&gt; -&gt; &amp;String -&gt; &amp;str
<span class="boring">}
</span></code></pre></pre>
<h4 id="derefmut-trait"><a class="header" href="#derefmut-trait"><code>DerefMut</code> trait</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait DerefMut: Deref {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target;
}
<span class="boring">}
</span></code></pre></pre>
<p>用于从可变的智能指针获得对象的可变引用</p>
<h2 id="drop-trait"><a class="header" href="#drop-trait"><code>Drop</code> trait</a></h2>
<p><code>drop</code> trait 允许我们在值要离开作用域时执行一些代码，例如释放内存、文件、网络资源等。智能指针都实现了 <code>Drop</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Drop {
    fn drop(&amp;mut self);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>drop()</code> 方法不允许手动调用。如果需要提前释放资源，可以使用 <code>std::mem::drop</code> 函数（包含在 prelude 中）：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>drop(x);
<span class="boring">}
</span></code></pre></pre>
<h2 id="rct-引用计数"><a class="header" href="#rct-引用计数"><code>Rc&lt;T&gt;</code> 引用计数</a></h2>
<p>注意 <code>Rc&lt;T&gt;</code> 只能用于单线程场景</p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}
</code></pre></pre>
<p>这创建了一个如下所示的链表：</p>
<p><img src="Rust/.assets/image-20230105225435307.png" alt="image-20230105225435307" /></p>
<p><code>Rc&lt;T&gt;</code> 的 <code>clone</code> 与大多数类不同，不会进行深拷贝，仅会浅拷贝并增加计数。常用 <code>Rc::clone(&amp;a)</code> 而不是 <code>a.clone()</code> 以体现其中的区别。<code>Rc&lt;T&gt;</code> 被 <code>drop()</code> 时计数减少。计数为零时释放资源</p>
<p>由于可以有多个 <code>Rc&lt;T&gt;</code> 指向同一对象，<code>Rc&lt;T&gt;</code> 没有实现 <code>DerefMut</code>，不允许通过 <code>Rc&lt;T&gt;</code> 对对象进行可变访问。</p>
<h2 id="refcellt"><a class="header" href="#refcellt"><code>RefCell&lt;T&gt;</code></a></h2>
<p><code>RefCell&lt;T&gt;</code> 与 <code>Box&lt;T&gt;</code> 一样，只能有单一所有者。<code>RefCell&lt;T&gt;</code> 只能用于单线程场景。<code>RefCell&lt;T&gt;</code> 的特点是允许在运行时执行借用检查，而且即使在 <code>RefCell&lt;T&gt;</code> 本身不可变的情况下仍允许改变其内部的值，即<strong>内部可变性</strong>模式。如果在运行时违反了借用规则，会产生 panic。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::new();
let sr = RefCell::new(s);
sr.borrow_mut().push_str(&quot;hi&quot;);
println!(&quot;{}&quot;, sr.borrow());
<span class="boring">}
</span></code></pre></pre>
<p><code>borrow</code> 方法返回 <code>Ref&lt;T&gt;</code> 类型的智能指针，<code>borrow_mut</code> 方法返回 <code>RefMut&lt;T&gt;</code> 类型的智能指针。<code>RefCell&lt;T&gt;</code> 会记录当前有多少个活动的 <code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code> 智能指针，以此执行运行时的借用检查，有少量性能损失。</p>
<h2 id="rct--refcellt"><a class="header" href="#rct--refcellt"><code>Rc&lt;T&gt;</code> + <code>RefCell&lt;T&gt;</code></a></h2>
<p>为了解决 <code>Rc&lt;T&gt;</code> 不能可变访问的问题，常常结合使用 <code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="引用循环"><a class="header" href="#引用循环">引用循环</a></h2>
<p>在 Rust 中，引用循环会导致内存泄漏。例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Node(Option&lt;RefCell&lt;Rc&lt;Node&gt;&gt;&gt;);

let a = Rc::new(Node(Some(RefCell::new(Rc::new(Node(None))))));
let b = Rc::new(Node(Some(RefCell::new(a.clone()))));
if let Some(r) = &amp;a.0 {
    *r.borrow_mut() = b.clone();
}
println!(&quot;{:?}&quot;, a);	// 会导致栈溢出
<span class="boring">}
</span></code></pre></pre>
<p>一种解决方案是重新组织数据结构，使得一部分引用拥有所有权而另一部分没有。具体参考 the book</p>
<div style="break-before: page; page-break-before: always;"></div><h4 id="创建新线程"><a class="header" href="#创建新线程">创建新线程</a></h4>
<p>使用 <code>thread::spawn()</code> 创建新线程，参数是一个闭包：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let handler = thread::spawn(|| {
    for i in 0..10 {
        println!(&quot;spawn:{i}&quot;);
        thread::sleep(Duration::from_millis(1));
    }
});
// do something ...
handler.join().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>注意主线程结束时会强制终止新线程，使用 <code>join()</code> 避免这一点</p>
<h4 id="move-闭包"><a class="header" href="#move-闭包"><code>move</code> 闭包</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];

let handle = thread::spawn(move || {
    println!(&quot;Here's a vector: {:?}&quot;, v);
});

handle.join().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>使用 <code>move</code> 闭包把捕获的值移动进新线程中，否则会有生命周期问题</p>
<h2 id="消息传递"><a class="header" href="#消息传递">消息传递</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (tx, rx) = mpsc::channel();		// 创建信道

thread::spawn(move || {
    tx.send(String::from(&quot;hi&quot;)).unwrap(); 	// 发送
});

println!(&quot;receive: {}&quot;, rx.recv().unwrap());	// 接收，阻塞
<span class="boring">}
</span></code></pre></pre>
<p><code>mpsc</code> 是多个生产者，单个消费者的缩写，此信道可以有多个发送端，即 <code>tx</code> 可以被克隆。
接收方法 <code>recv()</code> 是阻塞的，还有其他非阻塞的方法。另外，<code>rx</code> 可以做迭代器使用。</p>
<h2 id="共享状态"><a class="header" href="#共享状态">共享状态</a></h2>
<p>通过信道进行消息传递是一种单所有权的模式，而共享内存是一种多所有权的模式。</p>
<h4 id="mutext"><a class="header" href="#mutext"><code>Mutex&lt;T&gt;</code></a></h4>
<p>使用 <code>Mutex&lt;T&gt;</code> 可以实现互斥访问：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let m = Mutex::new(5);

{
    let mut num = m.lock().unwrap();	// 获取锁（阻塞），得到智能指针 MutexGuard&lt;i32&gt;
    *num = 6;
}	// 智能指针离开作用域，调用 drop() 归还锁
<span class="boring">}
</span></code></pre></pre>
<p>与 <code>RefCell&lt;T&gt;</code> 类似，<code>Mutex&lt;T&gt;</code> 具有内部可变性。区别在于 <code>RefCell&lt;T&gt;</code> 在共享（可变）访问时会 panic，<code>Mutex&lt;T&gt;</code> 在共享访问时会阻塞。另外，<code>Mutex&lt;T&gt;</code> 可能导致线程死锁。</p>
<h4 id="原子引用计数-arct"><a class="header" href="#原子引用计数-arct">原子引用计数 <code>Arc&lt;T&gt;</code></a></h4>
<p>与 <code>Rc&lt;T&gt;</code> 类似，<code>Arc&lt;T&gt;</code> 用于共享访问。但 <code>Rc&lt;T&gt;</code> 不是线程安全的，<code>Arc&lt;T&gt;</code> 线程安全，但有额外的性能损失。</p>
<p>常用 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 以在线程之间共享数据：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r = Arc::new(Mutex::new(0));
let r1 = r.clone();
thread::spawn(move || {
    let mut a = r1.lock().unwrap();
    *a += 1;
});
<span class="boring">}
</span></code></pre></pre>
<h2 id="并发相关-trait"><a class="header" href="#并发相关-trait">并发相关 trait</a></h2>
<h4 id="send-trait"><a class="header" href="#send-trait"><code>Send</code> trait</a></h4>
<p>这是一个标记 trait，表明一个类型的对象允许在线程之间转移所有权。只有少数类型没有实现 <code>Send</code>，如 <code>Rc&lt;T&gt;</code>。任何完全由 <code>Send</code> 的类型组成的类型也会自动被标记为 <code>Send</code>。</p>
<h4 id="sync-trait"><a class="header" href="#sync-trait"><code>Sync</code> trait</a></h4>
<p>这是一个标记 trait，表明一个类型 允许多个线程持有其对象的引用。如果 <code>&amp;T</code> 是 <code>Send</code> 的，<code>T</code> 就是 <code>Sync</code> 的。完全由 <code>Sync</code> 的类型组成的类型也是 <code>Sync</code> 的。</p>
<p><code>Rc&lt;T&gt;</code>、<code>RefCell&lt;T&gt;</code>、<code>Cell&lt;T&gt;</code> 系列类型不是 <code>Sync</code> 的。因为 <code>RefCell&lt;T&gt;</code> 在运行时进行的借用检查不是线程安全的。</p>
<blockquote>
<p>通常并不需要手动实现 <code>Send</code> 和 <code>Sync</code> trait，手动实现这些标记 trait 涉及到编写不安全的 Rust 代码。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="trait-对象"><a class="header" href="#trait-对象">trait 对象</a></h2>
<p>泛型类型参数一次只能替代一个具体类型，而 trait 对象则允许在运行时替代多种具体类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Show {
    fn show(&amp;self) -&gt; String;
}

fn show_all(v: Vec&lt;Box&lt;dyn Show&gt;&gt;) {	// trait 对象
    for i in v {
        println!(&quot;{}&quot;, i.show());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>trait bound 执行静态分发，trait 对象执行动态分发，即在运行时才能确定调用了什么方法。使用 trait 对象获得了额外的灵活性，但相比 trait bound 有性能损失</p>
<h4 id="对象安全"><a class="header" href="#对象安全">对象安全</a></h4>
<p>只有对象安全（object-safe）的 trait 才支持 trait 对象的使用。具体要求是：</p>
<ul>
<li>返回值不是 <code>Self</code></li>
<li>没有泛型类型的参数</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unsafe-rust"><a class="header" href="#unsafe-rust">unsafe Rust</a></h2>
<p>在 <code>unsafe</code> 块中，允许进行这五类特殊操作：</p>
<ul>
<li>解引用裸指针</li>
<li>调用不安全的函数或方法</li>
<li>访问或修改可变静态变量</li>
<li>实现不安全 trait</li>
<li>访问 <code>union</code> 的字段</li>
</ul>
<p>注意：<code>unsafe</code> 并不会关闭借用检查器或禁用任何其他 Rust 安全检查</p>
<p>创建不安全代码的安全抽象是 Rust 中一种重要的设计模式。将底层的、Rust 编译器不能理解的操作在 <code>unsafe</code> 块中实现，封装为安全的函数等抽象。</p>
<h4 id="裸指针"><a class="header" href="#裸指针">裸指针</a></h4>
<p>类型为 <code>*const T</code> 或 <code>*mut T</code>，分别是（底层）不可变或可变的。裸指针允许忽略借用规则、不保证指向有效的内存、允许为空、不能实现任何自动清理功能</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = 10;
let p: *mut i32 = &amp;mut a;	// 通过引用创建裸指针
let p = 0x0800_0000 as *mut i32;	// 通过地址创建裸指针
<span class="boring">}
</span></code></pre></pre>
<p>裸指针可以在安全代码中创建，但只能在 <code>unsafe</code> 中解引用</p>
<h4 id="调用不安全函数"><a class="header" href="#调用不安全函数">调用不安全函数</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn dangerous() {}
<span class="boring">}
</span></code></pre></pre>
<p>调用不安全函数需要在 <code>unsafe</code> 块中进行。不安全函数内部看作 <code>unsafe</code> 块，可以在其中进行各种 <code>unsafe</code> 操作</p>
<h4 id="外部函数接口"><a class="header" href="#外部函数接口">外部函数接口</a></h4>
<p>为了与其他语言编写的代码交互，可以通过外部函数接口（FFI）。外部函数总被认为是不安全的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>&quot;C&quot;</code> 定义了外部函数所使用的 应用二进制接口（ABI）。ABI 定义了如何在汇编语言层面调用此函数。<code>&quot;C&quot;</code> ABI 是最常见的，并遵循 C 编程语言的 ABI。</p>
<p>另外，可以将 Rust 函数提供给其他语言使用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;Just called a Rust function from C!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>#[no_mangle]</code> 注解要求 Rust 编译器不要 mangle 此函数的名称</p>
<h4 id="静态变量"><a class="header" href="#静态变量">静态变量</a></h4>
<p>静态变量即全局变量：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static MY_NAME: String = String::new();	// 不可变的
static mut AGE: u32 = 1;	// 可变的
<span class="boring">}
</span></code></pre></pre>
<p>访问不可变静态变量是安全的，任何对可变静态变量的访问都是不安全的</p>
<h4 id="不安全-trait"><a class="header" href="#不安全-trait">不安全 trait</a></h4>
<p>当 trait 中至少有一个方法中包含编译器无法验证的不变式（invariant）时 trait 是不安全的</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe trait Foo {...}
unsafe impl Foo for i32 {...}
<span class="boring">}
</span></code></pre></pre>
<h4 id="访问联合体"><a class="header" href="#访问联合体">访问联合体</a></h4>
<p>联合体 <code>union</code> 主要用于和 C 代码中的联合体交互，访问联合体的字段是不安全的</p>
<div style="break-before: page; page-break-before: always;"></div><p>宏在编译器翻译代码前展开，在一个文件里调用宏<strong>之前</strong>必须定义它，或将其引入作用域。</p>
<h4 id="基于-macro_rules-的声明宏"><a class="header" href="#基于-macro_rules-的声明宏">基于 <code>macro_rules!</code> 的声明宏</a></h4>
<p>例如：<code>vec!</code> 的简化定义</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="过程宏"><a class="header" href="#过程宏">过程宏</a></h4>
<h4 id="类属性宏"><a class="header" href="#类属性宏">类属性宏</a></h4>
<h4 id="类函数宏"><a class="header" href="#类函数宏">类函数宏</a></h4>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git"><a class="header" href="#git">Git</a></h1>
<p>大部分内容来源于</p>
<ul>
<li>《Pro Git》</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="模型"><a class="header" href="#模型">模型</a></h2>
<p>工作区，暂存区（索引），仓库</p>
<hr />
<h2 id="config"><a class="header" href="#config">config</a></h2>
<p>Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p>
<ol>
<li>/etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 git config 时带上 --system 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）</li>
<li>~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 你可以传递 --global 选项让 Git 读写此文件，这会对你系统上 所有 的仓库生效。</li>
<li>当前使用仓库的 Git 目录中的 config 文件（即 .git/config）：针对该仓库。 你可以传递 --local 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。（当然，你需要进入某个 Git 仓库中才能让该选项生效。）</li>
</ol>
<p>每一个级别会覆盖上一级别的配置</p>
<p>你可以通过以下命令查看所有的配置以及它们所在的文件：</p>
<pre><code class="language-shell">$ git config --list --show-origin
</code></pre>
<p>常用设置：</p>
<pre><code class="language-shell">$ git config --global user.name &quot;John Doe&quot;
$ git config --global user.email johndoe@example.com
$ git config --global core.editor vim
</code></pre>
<h2 id="别名-alias"><a class="header" href="#别名-alias">别名 alias</a></h2>
<pre><code class="language-shell">$ git config --global alias.st status
# git st == git status

$ git config --global alias.unstage 'reset HEAD --'
# git unstage fileA == git reset HEAD -- fileA

$ git config --global alias.st 'status -s'
</code></pre>
<hr />
<h2 id="gitignore"><a class="header" href="#gitignore">.gitignore</a></h2>
<p>.gitignore 使用标准的 glob 模式匹配</p>
<p>根目录下的 .gitignore 会递归地应用在整个工作区中</p>
<p>子目录中的 .gitignore 只作用于它所在的目录中</p>
<hr />
<h2 id="diff"><a class="header" href="#diff">diff</a></h2>
<p><code>git diff</code>：查看工作区和暂存区的差异</p>
<p><code>git diff --staged</code>：查看暂存区和最后一次提交的差异</p>
<p><code>git diff --check</code>：查找空白错误</p>
<hr />
<h2 id="rm--mv"><a class="header" href="#rm--mv">rm &amp; mv</a></h2>
<p>对工作区使用，如<code>git rm file</code>，效果和普通的<code>rm</code>一样，<strong>会将文件删除</strong>，只不过会把这个操作提交到暂存区。相当于<code>rm file &amp; git add file</code>。</p>
<p>对暂存区使用，如<code>git rm --cached file</code>，会删除暂存区中的该文件</p>
<blockquote>
<p>似乎等同于<code>git restore --staged file</code></p>
</blockquote>
<p><code>git mv</code>和普通的<code>mv</code>一样，只不过会把这个操作提交到暂存区。</p>
<p>git并不会跟踪重命名，它只记录增删。关于git如何识别重命名，可参考https://chelseatroy.com/2020/05/09/question-how-does-git-detect-renames/。</p>
<p>简单来说，git会使用特定的算法（用户可以配置）检查增加和删除的文件之间的相似度，与一个阈值（用户可以配置）相比较，超过即视为重命名。</p>
<hr />
<h2 id="log"><a class="header" href="#log">log</a></h2>
<p><code>git log</code>有很多参数，配置输出的格式，筛选条件:bookmark_tabs:</p>
<hr />
<h2 id="commit"><a class="header" href="#commit">commit</a></h2>
<pre><code class="language-shell">$ git commit --amend
</code></pre>
<p>效果上大致为：立即产生一个新的 commit ，合并到前一个 commit ，可以重新编辑提交信息。类似简单的 rebase。</p>
<hr />
<h2 id="restore"><a class="header" href="#restore">restore</a></h2>
<p>用于恢复</p>
<p>当作用于暂存区时<code>git restore --staged file</code>，删除暂存区内的该文件（相当于撤销 add），即恢复暂存区</p>
<p>当作用于工作区时<code>git restore file</code>，将工作区内该文件恢复到与<strong>暂存区</strong>相同</p>
<hr />
<h2 id="remote"><a class="header" href="#remote">remote</a></h2>
<pre><code class="language-shell">$ git remote					#列出每一个远程服务器的简写
$ git remote -v					#查看详细信息
$ git remote show &lt;remote&gt;		#查看一个远程仓库的更多信息
$ git remote rename &lt;remote&gt; &lt;new_remote&gt;	#重命名
$ git remote remove &lt;remote&gt;	#删除

$ git fetch &lt;remote&gt;
$ git push &lt;remote&gt; &lt;branch&gt;
</code></pre>
<hr />
<h2 id="tag"><a class="header" href="#tag">tag</a></h2>
<p><code>git tag</code>列出标签</p>
<p>标签有两种：轻量标签和附注标签</p>
<pre><code class="language-shell">git tag -a &lt;tagname&gt;	#创建附注标签，可加-m，可加目标commit的校验和
git tag &lt;tagname&gt;		#创建轻量标签，不加-m
git tag -d &lt;tagname&gt;	#删除标签
git show &lt;tagname&gt;	  	#查看某个标签的信息和提交信息
git checkout &lt;tagname&gt;	#检出标签，也就是检出该版本
</code></pre>
<p>默认情况下，<code>git push</code>不会传送标签到远程仓库</p>
<pre><code class="language-shell">git push origin &lt;tagname&gt;	#推送指定标签
git push origin --tags		#推送全部标签
git push origin --delete &lt;tagname&gt;	#推送对标签的删除
</code></pre>
<hr />
<h2 id="分支"><a class="header" href="#分支">分支</a></h2>
<img src="Git/assets/2022-01-21 00-22-07 的屏幕截图.png" alt="2022-01-21 00-22-07 的屏幕截图" style="zoom:50%;" />
<p>白色方块是 commit 对象，Snapshot是快照。分支就是指向 commit 对象的指针。HEAD 指针指向分支 master。</p>
<pre><code class="language-shell">git branch			 	# 查看所有分支
git branch &lt;name&gt;	 	# 创建新分支(在当前所在的提交对象上)
git branch -d &lt;name&gt; 	# 删除分支
git checkout &lt;name&gt;	 	# 切换到一个分支
git checkout -b &lt;name&gt;	# 创建新分支，同时切换过去
</code></pre>
<p>切换分支之前，最好保持工作区干净。但也有一些办法绕过这个问题：暂存和修补提交。:construction:</p>
<pre><code class="language-shell">git merge &lt;name&gt;	# 将分支&lt;name&gt;合并到当前分支
</code></pre>
<p>如果发生冲突，需要手动合并。可以使用<code>git status</code>查看状态，用<code>git add</code>将文件标记为已完成合并，最后<code>git commit</code>。</p>
<h2 id="远程分支"><a class="header" href="#远程分支">远程分支</a></h2>
<p>以<code>&lt;remote&gt;/&lt;branch_name&gt;</code>的方式命名，如<code>origin/master</code>，反映远程仓库的状态（上游分支），本地不可修改。在每次<code>fetch</code>时更新。</p>
<pre><code class="language-shell">git push &lt;remote&gt; &lt;name&gt;	# 将本地的&lt;name&gt;分支推送到&lt;remote&gt;
</code></pre>
<p>本地分支可以<strong>跟踪</strong>远程分支，以便<code>git push/pull</code>等</p>
<pre><code class="language-shell">git branch -u &lt;remote/branch_name&gt;	# 设置本地分支跟踪远程分支
git checkout --track &lt;remote/branch_name&gt; # 新建一个同名本地分支来跟踪远程分支
</code></pre>
<h2 id="rebase"><a class="header" href="#rebase">rebase</a></h2>
<p>将提交到某一分支上的所有修改都作用到另一分支上，消除分支，使历史整洁</p>
<pre><code class="language-shell">git rebase &lt;branch&gt;	# 将当前分支变基到&lt;branch&gt;上
git rebase &lt;base&gt; &lt;topic&gt; # 将&lt;topic&gt;变基到&lt;base&gt;上
</code></pre>
<p>变基的高级操作:bookmark_tabs:</p>
<hr />
<h2 id="工作流程"><a class="header" href="#工作流程">工作流程</a></h2>
<ol>
<li>集中式工作流</li>
</ol>
<img src="Git/assets/2022-01-21 17-09-30 的屏幕截图.png" alt="2022-01-21 17-09-30 的屏幕截图" style="zoom:50%;" />
<p>一个公共的远程仓库</p>
<ol start="2">
<li>集成管理者工作流</li>
</ol>
<img src="Git/assets/2022-01-21 17-10-32 的屏幕截图.png" alt="2022-01-21 17-10-32 的屏幕截图" style="zoom:50%;" />
<p>一个官方的远程仓库，每个开发者有一个自己的远程仓库。</p>
<p>管理者在其本地仓库中，将开发者的仓库添加为远程仓库，进行合并，然后推送到官方远程仓库。</p>
<ol start="3">
<li>主管与副主管工作流</li>
</ol>
<p>非常庞大的项目使用:bookmark_tabs:</p>
<p>更多内容, 作为贡献者/管理员的操作方法:construction:</p>
<hr />
<h2 id="github"><a class="header" href="#github">GitHub</a></h2>
<p>利用 PR 管理项目</p>
<p>服务</p>
<p>钩子（Webhook）。GitHub 在检测到特定事件时，可以发送一个 POST 请求。</p>
<p>GitHub 的 API</p>
<hr />
<h2 id="stash"><a class="header" href="#stash">stash</a></h2>
<p>在 checkout 之前最好保持工作区干净</p>
<p>如果想要 checkout 但是工作区不干净，可以使用<code>git stash push</code>，将改动压入一个栈结构中（贮藏）。同时会清除工作区中的任何改动。</p>
<pre><code class="language-shell">$ git stash push

$ git stash list	# 查看栈上所有贮藏
	stash@{0}: WIP on master: 3c89231 Merge branch 'test'

$ git stash apply	# 应用一个贮藏，默认最近入栈的
$ git stash apply stash@{0}	# 指定栈上的某一个贮藏
$ git stash drop stash@{0}	# apply不会删除栈上的贮藏，需要手动删除
$ git stash pop		# 应用，同时删除
</code></pre>
<p>可以在一个分支上贮藏改动，然后应用到另一个分支上</p>
<hr />
<h2 id="clean"><a class="header" href="#clean">clean</a></h2>
<p><code>git clean</code> 移除没有被 <code>.gitignore</code> 忽略的未跟踪文件</p>
<p>添加参数 <code>--dry-run</code> 或 <code>-n</code> 以进行一次演习，不实际执行删除</p>
<p>添加参数 <code>-x</code> 移除被 <code>.gitignore</code>忽略的文件</p>
<hr />
<h2 id="gpg-签署"><a class="header" href="#gpg-签署">GPG 签署</a></h2>
<p>:bookmark_tabs:</p>
<hr />
<h2 id="git-搜索和日志搜索"><a class="header" href="#git-搜索和日志搜索">Git 搜索和日志搜索</a></h2>
<p>:bookmark_tabs:</p>
<hr />
<h2 id="交互式变基"><a class="header" href="#交互式变基">交互式变基</a></h2>
<pre><code class="language-bash">git rebase -i HEAD~3
</code></pre>
<p>:bookmark_tabs:</p>
<hr />
<h2 id="filter-branch"><a class="header" href="#filter-branch">filter-branch</a></h2>
<p>用于进行全局历史的改写，比如从每一个提交中删除某个文件</p>
<pre><code class="language-bash">git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
</code></pre>
<p>:bookmark_tabs:</p>
<hr />
<h2 id="reset"><a class="header" href="#reset">reset</a></h2>
<p><code>git reset</code> 和 checkout 很类似，但是 checkout 只移动 HEAD 指针，reset 会同时移动 HEAD 指针和 HEAD 指针指向的分支。</p>
<p>当给定一些参数时：</p>
<table><thead><tr><th>参数</th><th>效果</th></tr></thead><tbody>
<tr><td>--soft</td><td>仅移动 HEAD 和它指向的分支</td></tr>
<tr><td>--mixed</td><td>移动，然后更新暂存区（默认）</td></tr>
<tr><td>--hard</td><td>移动，然后更新暂存区和工作区（会导致工作区数据被覆盖）</td></tr>
</tbody></table>
<hr />
<h2 id="子模块"><a class="header" href="#子模块">子模块</a></h2>
<p>:bookmark_tabs:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="51单片机"><a class="header" href="#51单片机">51单片机</a></h1>
<p>大部分内容来源于 </p>
<ul>
<li>《零基础学单片机C语言程序设计》（机械工业出版社）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="串行接口"><a class="header" href="#串行接口">串行接口</a></h2>
<p>发送/接收缓冲器 SBUF</p>
<p><strong>串行接口控制寄存器SCON</strong></p>
<table><thead><tr><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody>
<tr><td>SM0</td><td>SM1</td><td>SM2</td><td>REN</td><td>TB8</td><td>RB8</td><td>TI</td><td>RI</td></tr>
</tbody></table>
<table><thead><tr><th>SM0</th><th>SM1</th><th>工作方式</th><th>功能</th><th>波特率</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>工作模式0</td><td>同步移位寄存器方式</td><td>$f_{osc}/12$</td></tr>
<tr><td>0</td><td>1</td><td>工作模式1</td><td>10位异步发送接收方式</td><td>由定时器控制</td></tr>
<tr><td>1</td><td>0</td><td>工作模式2</td><td>11位异步发送接收方式</td><td>$f_{osc}/32$或$f_{osc}/64$</td></tr>
<tr><td>1</td><td>1</td><td>工作模式3</td><td>11位异步发送接收方式</td><td>由定时器控制</td></tr>
</tbody></table>
<ul>
<li>SM2 : 多机串行通信的控制位. SM2 = 1时, (从机)仅接收地址帧(RB8 = 1), SM2 = 0时, (从机)接收所有数据.</li>
<li>REN : 串行数据接收允许/禁止控制位. REN = 1时, 允许接收串行数据; REN = 0时, 禁止接收串行数据.</li>
<li>TB8 : 主要用于模式2和3中, 作为<strong>发送</strong>数据的第9位, 在模式0和模式1中, TB8位不使用. 常作为奇偶校验位, 在多机串行通信中, 也可以作为地址帧和数据帧的区分标志位.</li>
<li>RB8 : 主要用于模式2和3中, 作为<strong>接收</strong>数据的第9位. 在模式1中, 如果SM2 = 0, 即采用的不是多机通信模式, 则RB8是已接收到的停止位. 在模式0中, 该位不使用.</li>
<li>TI : 串行数据发送中断请求标志位. 在一帧串行数据发送结束的时候, 由单片机硬件自动置位. 如果 TI = 1 则表示发送缓冲器已空, 通知CPU可以发送下一帧数据. 在模式0中, 串行发送完8位数据时便进行硬件置位, 其他模式中, 串行发送到停止位的时候由硬件置位. <strong>不会自动复位, 需要手动清零</strong>.</li>
<li>RI : 串行数据接收中断请求标志位. 在接收到一帧有效的串行数据后, 由单片机硬件置位. 如果 RI = 1 则表示接收缓冲器已满, 通知CPU可以将数据取走. 在模式0中, 串行接收完8位数据时便进行硬件置位, 其他模式中, 串行接收到停止位的时候由硬件置位. <strong>不会自动复位, 需要手动清零</strong>.</li>
</ul>
<p><strong>特殊功能寄存器PCON</strong> <strong>(不支持位寻址)</strong></p>
<table><thead><tr><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody>
<tr><td>SMOD</td><td>-</td><td>-</td><td>-</td><td>GF1</td><td>GF0</td><td>PD</td><td>IDL</td></tr>
</tbody></table>
<ul>
<li>D0~D3表示CHMOS型单片机的掉电控制位</li>
<li>SMOD : 波特率倍增位, 在模式1,2,3下, 如果置SMOD = 1, 则波特率提高一倍, 如果SMOD = 0, 则波特率不变. 在模式0下不起作用.</li>
</ul>
<table><thead><tr><th>波特率(bit/s)</th><th>\(f_{osc}(MHz)\)</th><th>SMOD</th><th>T1工作模式</th><th>初值</th></tr></thead><tbody>
<tr><td>4800</td><td>16</td><td>1</td><td>2</td><td>EFH</td></tr>
<tr><td>2400</td><td>16</td><td>0</td><td>2</td><td>EFH</td></tr>
<tr><td>2400</td><td>16</td><td>1</td><td>2</td><td>DDH</td></tr>
<tr><td>1200</td><td>16</td><td>0</td><td>2</td><td>DDH</td></tr>
<tr><td>1200</td><td>16</td><td>1</td><td>2</td><td>BBH</td></tr>
<tr><td>600</td><td>16</td><td>0</td><td>2</td><td>BBH</td></tr>
<tr><td>600</td><td>16</td><td>1</td><td>2</td><td>75H</td></tr>
<tr><td>300</td><td>16</td><td>0</td><td>2</td><td>75H</td></tr>
<tr><td>4800</td><td>12</td><td>1</td><td>2</td><td>F3H</td></tr>
<tr><td>2400</td><td>12</td><td>0</td><td>2</td><td>F3H</td></tr>
<tr><td>2400</td><td>12</td><td>1</td><td>2</td><td>E6H</td></tr>
<tr><td>1200</td><td>12</td><td>0</td><td>2</td><td>E6H</td></tr>
<tr><td>1200</td><td>12</td><td>1</td><td>2</td><td>CCH</td></tr>
<tr><td>600</td><td>12</td><td>0</td><td>2</td><td>CCH</td></tr>
<tr><td>600</td><td>12</td><td>1</td><td>2</td><td>98H</td></tr>
<tr><td>300</td><td>12</td><td>0</td><td>2</td><td>98H</td></tr>
<tr><td>300</td><td>12</td><td>1</td><td>2</td><td>30H</td></tr>
<tr><td>110</td><td>12</td><td>0</td><td><strong>1</strong></td><td>FEEBH</td></tr>
<tr><td>56800</td><td>11.0592</td><td>1</td><td>2</td><td>FFH</td></tr>
<tr><td>19200</td><td>11.0592</td><td>1</td><td>2</td><td>FDH</td></tr>
<tr><td>9600</td><td>11.0592</td><td>0</td><td>2</td><td>FDH</td></tr>
<tr><td>9600</td><td>11.0592</td><td>1</td><td>2</td><td>FAH</td></tr>
<tr><td>4800</td><td>11.0592</td><td>0</td><td>2</td><td>FAH</td></tr>
<tr><td>4800</td><td>11.0592</td><td>1</td><td>2</td><td>F4H</td></tr>
<tr><td>2400</td><td>11.0592</td><td>0</td><td>2</td><td>F2H</td></tr>
<tr><td>2400</td><td>11.0592</td><td>1</td><td>2</td><td>E8H</td></tr>
<tr><td>1200</td><td>11.0592</td><td>0</td><td>2</td><td>E8H</td></tr>
<tr><td>1200</td><td>11.0592</td><td>1</td><td>2</td><td>D0H</td></tr>
<tr><td>600</td><td>11.0592</td><td>0</td><td>2</td><td>D0H</td></tr>
<tr><td>600</td><td>11.0592</td><td>1</td><td>2</td><td>A0H</td></tr>
<tr><td>300</td><td>11.0592</td><td>0</td><td>2</td><td>A0H</td></tr>
<tr><td>300</td><td>11.0592</td><td>1</td><td>2</td><td>40H</td></tr>
<tr><td>1200</td><td>6</td><td>0</td><td>2</td><td>F3H</td></tr>
<tr><td>110</td><td>6</td><td>0</td><td>2</td><td>72H</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="定时器计数器"><a class="header" href="#定时器计数器">定时器/计数器</a></h2>
<p>定时器/计数器 T0 (P3.4)</p>
<ul>
<li>16位 TL0 TH0</li>
</ul>
<p>定时器/计数器 T1 (P3.5)</p>
<ul>
<li>16位 TL1 TH1 </li>
</ul>
<p><strong>方式控制寄存器TMOD (不支持位寻址)</strong></p>
<table><thead><tr><th align="center">D7</th><th align="center">D6</th><th align="center">D5</th><th align="center">D4</th><th align="center">D3</th><th align="center">D2</th><th align="center">D1</th><th align="center">D0</th></tr></thead><tbody>
<tr><td align="center">GATE</td><td align="center">C/T</td><td align="center">M1</td><td align="center">M0</td><td align="center">GATE</td><td align="center">C/T</td><td align="center">M1</td><td align="center">M0</td></tr>
<tr><td align="center">T1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">T0</td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
</tbody></table>
<ul>
<li>GATE = 0 时, 定时器/计数器工作仅受 TR0/TR1 的控制, TR0/TR1 = 1 时工作;</li>
<li>GATE = 1 时, 定时器/计数器工作受 TR0/TR1 和外部引脚 INT0/INT1控制, 均为1时工作.
<ul>
<li>INT0 : P3.2 ; INT1 : P3.3</li>
</ul>
</li>
<li>C/T = 0 时, 以定时器方式工作, 将外部晶振的12分频信号作为计数信号;</li>
<li>C/T = 1 时, 以计数器方式工作, 接受 T0/T1 的负跳变, 最高频率为晶振频率的$\frac{1}{24}$.</li>
<li>常用GATE = 1, C/T = 0的方式测量 INT0/INT1 正脉冲的宽度</li>
</ul>
<table><thead><tr><th align="center">M1</th><th align="center">M0</th><th align="center">工作模式</th><th align="center">功能</th></tr></thead><tbody>
<tr><td align="center">0</td><td align="center">0</td><td align="center">模式0</td><td align="center">13位 (<strong>TL的低5位和TH的8位</strong>)</td></tr>
<tr><td align="center">0</td><td align="center">1</td><td align="center">模式1</td><td align="center">16位</td></tr>
<tr><td align="center">1</td><td align="center">0</td><td align="center">模式2</td><td align="center">8位, TL自动重新装入TH初值</td></tr>
<tr><td align="center">1</td><td align="center">1</td><td align="center">模式3</td><td align="center">T0分为两个8位,TH0仅定时,占用T1,T1不可用</td></tr>
</tbody></table>
<p><strong>控制寄存器TCON</strong></p>
<table><thead><tr><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody>
<tr><td>TF1</td><td>TR1</td><td>TF0</td><td>TR0</td><td>IE1</td><td>IT1</td><td>IE0</td><td>IT0</td></tr>
</tbody></table>
<ul>
<li>TF1 : 定时器/计数器T1的溢出标志位</li>
<li>TR1 : 定时器/计数器T1的启/停控制位</li>
<li>TF0 : 定时器/计数器T0的溢出标志位</li>
<li>TR0 : 定时器/计数器T0的启/停控制位</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="中断"><a class="header" href="#中断">中断</a></h2>
<p><strong>中断源</strong></p>
<ul>
<li>INT0 : 外部中断0, P3.2</li>
<li>INT1 : 外部中断1, P3.3</li>
<li>TF0 : 定时器/计数器T0溢出中断</li>
<li>TF1 : 定时器/计数器T1溢出中断</li>
<li>TI : 串行发送中断源</li>
<li>RI : 串行接收中断源</li>
</ul>
<p><strong>控制寄存器TCON</strong></p>
<table><thead><tr><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody>
<tr><td>TF1</td><td>TR1</td><td>TF0</td><td>TR0</td><td>IE1</td><td>IT1</td><td>IE0</td><td>IT0</td></tr>
</tbody></table>
<ul>
<li>TF1 : 定时器/计数器T1的溢出标志位</li>
<li>TR1 : 定时器/计数器T1的启/停控制位</li>
<li>TF0 : 定时器/计数器T0的溢出标志位</li>
<li>TR0 : 定时器/计数器T0的启/停控制位</li>
<li>IE1 : INT1 中断请求标志位</li>
<li>IT1 : INT1 中断触发方式控制位, IT1 = 0 时, 低电平触发; IT1 = 1 时, 下降沿触发</li>
<li>IE0 : INT0 中断请求标志位</li>
<li>IT0 : INT0 中断触发方式控制位, IT0 = 0 时, 低电平触发; IT0 = 1 时, 下降沿触发</li>
</ul>
<p><strong>控制寄存器SCON</strong></p>
<table><thead><tr><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody>
<tr><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>TI</td><td>RI</td></tr>
</tbody></table>
<ul>
<li>
<p>RI : 串行接口接收数据中断请求标志位, 需要在中断函数中手工清除中断</p>
</li>
<li>
<p>TI : 串行接口发送数据中断请求标志位, 需要在中断函数中手工清除中断</p>
</li>
</ul>
<p><strong>中断允许控制寄存器IE</strong></p>
<table><thead><tr><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody>
<tr><td>EA</td><td>-</td><td>-</td><td>ES</td><td>ET1</td><td>EX1</td><td>ET0</td><td>EX0</td></tr>
</tbody></table>
<ul>
<li>EA : 中断禁止/允许总控制位, EA = 0 时, 禁止所有中断请求</li>
<li>ES : 串行中断禁止/允许控制位, ES = 0 时, 禁止串行口中断, ES = 1 时, 允许串行口中断</li>
<li>ET1 : 定时器/计数器T1禁止/允许控制位</li>
<li>EX1 : INT1 禁止/允许控制位</li>
<li>ET0 : 定时器/计数器T0禁止/允许控制位</li>
<li>EX0 : INT0 禁止/允许控制位</li>
</ul>
<p><strong>中断优先级控制寄存器IP</strong></p>
<table><thead><tr><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody>
<tr><td>-</td><td>-</td><td>-</td><td>PS</td><td>PT1</td><td>PX1</td><td>PT0</td><td>PX0</td></tr>
</tbody></table>
<ul>
<li>PS : 串行接口中断优先级设置位, PS = 0 时, 设置为低优先级, PS = 1 时, 设置为高优先级</li>
<li>PT1 : 定时器/计数器T1优先级设置位</li>
<li>PX1 : INT1优先级设置位</li>
<li>PT0 : 定时器/计数器T0优先级设置位</li>
<li>PX0 : INT0优先级设置位</li>
</ul>
<p><strong>中断号</strong></p>
<table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody>
<tr><td>INT0</td><td>T0</td><td>INT1</td><td>T1</td><td>串行接口中断</td><td>T2</td><td>PCA中断</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="储存类型"><a class="header" href="#储存类型">储存类型</a></h2>
<table><thead><tr><th align="center">储存类型</th><th align="center">储存区和储存方式</th></tr></thead><tbody>
<tr><td align="center">code</td><td align="center">程序代码储存区（64KB）</td></tr>
<tr><td align="center">data</td><td align="center">直接寻址片内数据存储区，访问速度快（128字节）</td></tr>
<tr><td align="center">bdata</td><td align="center">可位寻址片内数据存储区，允许位与字节混合访问（16字节）</td></tr>
<tr><td align="center">idata</td><td align="center">间接寻址片内数据存储区，可访问片内全部RAM地址空间（256字节）</td></tr>
<tr><td align="center">pdata</td><td align="center">分页寻址外部数据存储区（256字节）</td></tr>
<tr><td align="center">xdata</td><td align="center">可寻址片外数据存储区（64KB）</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stm32"><a class="header" href="#stm32">STM32</a></h1>
<p>大部分内容来源于</p>
<ul>
<li>https://www.youtube.com/playlist?list=PLERTijJOmYrDiiWd10iRHY0VRHdJwUH4g</li>
<li>https://interrupt.memfault.com/tag/zero-to-main/</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="工具链"><a class="header" href="#工具链">工具链</a></h2>
<ul>
<li>GNU 的 GCC for ARM</li>
<li>ARM 的 armcc ( KEIL附带, 有限制, 需要license)</li>
</ul>
<h3 id="gnu-gcc-for-arm"><a class="header" href="#gnu-gcc-for-arm">GNU GCC for ARM</a></h3>
<p>文档: https://gcc.gnu.org/onlinedocs/gcc/</p>
<table><thead><tr><th>工具 arm-none-eabi-</th><th>用途</th></tr></thead><tbody>
<tr><td>gcc</td><td>编译、链接、汇编</td></tr>
<tr><td>ld</td><td>链接</td></tr>
<tr><td>as</td><td>汇编</td></tr>
<tr><td>objdump / readelf / nm</td><td>ELF 文件分析</td></tr>
<tr><td>objcopy</td><td>格式转换</td></tr>
</tbody></table>
<h3 id="编译流程"><a class="header" href="#编译流程">编译流程</a></h3>
<ol>
<li>main.c -&gt; 预处理 -&gt; main.i -&gt; 编译 -&gt; main.s -&gt; 汇编 -&gt; main.o (可重定位目标文件, 不包含任何绝对地址, elf格式)</li>
<li>所有.o文件, .a库文件 -&gt; 链接 -&gt; main.elf</li>
<li>main.elf -&gt; objcopy -&gt; .ihex .bin 文件</li>
</ol>
<h3 id="arm-none-eabi-gcc-编译"><a class="header" href="#arm-none-eabi-gcc-编译">arm-none-eabi-gcc 编译</a></h3>
<table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody>
<tr><td>-c</td><td>只编译到.o, 不链接</td></tr>
<tr><td>-S</td><td>只编译到.s</td></tr>
<tr><td>-march / -mtune / -mcpu</td><td>指定目标架构/CPU</td></tr>
<tr><td>-mthumb / -marm</td><td>使用 thumb 或 arm 指令集</td></tr>
<tr><td>-mfloat-abi</td><td>指定浮点数的处理方法, 选项有 soft softfp hard, 一般会根据目标自动选定</td></tr>
<tr><td>-std</td><td>指定C语言标准</td></tr>
<tr><td>-Wall</td><td>启用所有被认为与用相关的警告</td></tr>
<tr><td>-Wextra</td><td>启用一些 -Wall 未启用的警告</td></tr>
<tr><td>-g</td><td>生成调试信息</td></tr>
<tr><td>-O</td><td>指定优化等级</td></tr>
</tbody></table>
<p>例</p>
<pre><code class="language-shell">arm-none-eabi-gcc -mcpu=cortex-m3 -mthumb -std=gnu17 -c main.c -o main.o
</code></pre>
<h3 id="arm-none-eabi-gcc-链接"><a class="header" href="#arm-none-eabi-gcc-链接">arm-none-eabi-gcc 链接</a></h3>
<table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody>
<tr><td>-T</td><td>指定链接脚本</td></tr>
<tr><td>-Wl,-Map=xxx</td><td>输出map文件, 前面的 -Wl 用于指明这是一个链接参数</td></tr>
<tr><td>-nostdlib</td><td>不使用任何标准库</td></tr>
<tr><td>-specs=xxx</td><td>指定使用的 specs 文件, 进而指定要链接的库</td></tr>
<tr><td>-specs=nano.specs</td><td>使用 newlib_nano 库, 否则默认使用 newlib 库.<br />nano 库程序体积小, 功能略弱 (如浮点相关). 库中有一些桩函数 (stub), 需要自己实现, 如 _write 等</td></tr>
<tr><td>-specs=nosys.specs</td><td>使用空的桩函数, 无需自己打桩, 但是会导致一些库函数, 如 printf 不能正常使用</td></tr>
</tbody></table>
<h3 id="elf-文件分析"><a class="header" href="#elf-文件分析">elf 文件分析</a></h3>
<p>Executable and Linkable Format
由 GNU 工具链使用的格式，其他工具链有别的格式
.o 和 .elf 文件均是这种格式</p>
<ol>
<li>读取各段和大小等信息</li>
</ol>
<pre><code class="language-shell">&gt; arm-none-eabi-objdump -h main.o

main.o:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000520  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000001  00000000  00000000  00000554  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000054  00000000  00000000  00000558  2**2
                  ALLOC
  3 .rodata       000000c9  00000000  00000000  00000558  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .comment      0000001f  00000000  00000000  00000621  2**0
                  CONTENTS, READONLY
  5 .ARM.attributes 0000002d  00000000  00000000  00000640  2**0
                  CONTENTS, READONLY
</code></pre>
<ol start="2">
<li>查看各段反汇编</li>
</ol>
<pre><code class="language-shell">&gt; arm-none-eabi-objdump -D main.o
</code></pre>
<ol start="3">
<li>直接查看各段内容</li>
</ol>
<pre><code class="language-shell">&gt; arm-none-eabi-objdump -s main.o
</code></pre>
<p>在 .o 文件中, 各段 (起始地址) 都被定位到 0 . 在之后的链接阶段会被重定位.</p>
<h3 id="arm-none-eabi-nm"><a class="header" href="#arm-none-eabi-nm">arm-none-eabi-nm</a></h3>
<p>用于查看文件中的符号</p>
<pre><code class="language-shell">arm-none-eabi-nm target.elf
</code></pre>
<h3 id="arm-none-eabi-size"><a class="header" href="#arm-none-eabi-size">arm-none-eabi-size</a></h3>
<p>注意：</p>
<ul>
<li>链接文件里给堆栈预留的大小似乎会算进 bss 大小里。</li>
<li>中断向量似乎会算进 data 大小里</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="内存布局"><a class="header" href="#内存布局">内存布局</a></h3>
<img src="STM32/assets/image-20230412174354562.png" alt="image-20230412174354562" style="zoom: 80%;" />
<p>注意：不是所有工具链都采用这种布局。<a href="https://aijishu.com/a/1060000000366626">参考资料</a></p>
<h3 id="启动文件的内容"><a class="header" href="#启动文件的内容">启动文件的内容</a></h3>
<ol>
<li>设置中断向量表</li>
<li>初始化 SRAM 中的 .data 和 .bss 段</li>
<li>如果使用标准库的话, 调用 <code>__libc_init_array()</code></li>
<li>调用 <code>main()</code></li>
</ol>
<h3 id="中断向量表"><a class="header" href="#中断向量表">中断向量表</a></h3>
<ul>
<li>
<p>初始 MSP 值</p>
</li>
<li>
<p>15个系统异常（包括 <code>Reset_Handler</code>）</p>
</li>
<li>
<p>n个IRQs</p>
</li>
</ul>
<p>总共占用 \( (1+15+n)\times4\ {byte} \).</p>
<h3 id="复位流程"><a class="header" href="#复位流程">复位流程</a></h3>
<p>参考 ARM 架构部分的笔记。</p>
<ol>
<li>从 <code>0x0000_0000</code> 取 MSP</li>
<li>从 <code>0x0000_0004</code> 取 <code>Reset_Handler</code> 到 PC</li>
<li>执行 <code>Reset_Handler</code> 函数</li>
</ol>
<h3 id="初始化-data-和-bss"><a class="header" href="#初始化-data-和-bss">初始化 .data 和 .bss</a></h3>
<p>在 Reset_Handler 里初始化 SRAM 中的 .data 和 .bss 段</p>
<p>.data 段复制到 SRAM 中, .bss 段清空</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="语法"><a class="header" href="#语法">语法</a></h2>
<h3 id="entry"><a class="header" href="#entry">ENTRY</a></h3>
<pre><code>ENTRY(Reset_Handler)
</code></pre>
<p>指定程序的入口, 不是必须的, 对调试器有用</p>
<h3 id="memory"><a class="header" href="#memory">MEMORY</a></h3>
<pre><code>MEMORY
{
    FLASH(rx): ORIGIN=0x08000000, LENGTH=64K
    SRAM(rwx): ORIGIN=0x20000000, LENGTH=20K
}
</code></pre>
<p>指定内存布局</p>
<table><thead><tr><th>attribute (不区分大小写)</th><th>含义</th></tr></thead><tbody>
<tr><td><code>r</code></td><td>只读</td></tr>
<tr><td><code>w</code></td><td>可读可写</td></tr>
<tr><td><code>x</code></td><td>可执行</td></tr>
<tr><td><code>a</code></td><td>可以 allocate</td></tr>
<tr><td><code>i</code></td><td>初始化的段</td></tr>
<tr><td><code>l</code></td><td>与 <code>i</code> 相同</td></tr>
<tr><td><code>!</code></td><td>其后的 attribute 含义取反</td></tr>
</tbody></table>
<h3 id="section"><a class="header" href="#section">SECTION</a></h3>
<pre><code>SECTIONS
{
    .text:
    {
        *(.isr_vector)
        *(.text)
        *(.rodata)
    }&gt; FLASH

    .data:
    {
        *(.data)
    }&gt; SRAM AT&gt; FLASH

    .bss:
    {
        *(.bss)
    }&gt; SRAM
}
</code></pre>
<p>指定最终输出的段及其位置, 这些段整合了来自.o文件的段</p>
<p>VMA(虚拟地址) 和 LMA(加载地址)</p>
<h3 id="地址计数器"><a class="header" href="#地址计数器">地址计数器(.)</a></h3>
<p>只能在 SECTIONS 命令内使用, 就是一个点符号, 表示当前地址</p>
<p>注意: 地址计数器追踪的是 VMA 地址</p>
<h3 id="symbol"><a class="header" href="#symbol">SYMBOL</a></h3>
<p>在链接脚本里可以用类似 C 赋值的语法创建 symbol, 创建的 symbol 直接加入到符号表里, 并可以在 C 代码中引用.</p>
<p>下面的例子追踪了 .data 段的起始和结束地址 (VMA)</p>
<pre><code>.data:
{
    _sdata = .;
    *(.data)
    _edata = .;
}&gt; SRAM AT&gt; FLASH
</code></pre>
<blockquote>
<p>注意：这样创建出来的符号并不是一个地址（u32 *），而是一个放在该位置的虚拟的变量（u32）。通常我们需要的是它的地址，应当这样写：</p>
<pre><code class="language-c">uint32_t* p = &amp;_sdata;	// 此时 p 的值为 data 段的起始地址
</code></pre>
</blockquote>
<hr />
<p>标准库需要一些来自链接文件的符号</p>
<p>如 <code>__bss_start__</code>, <code>__bss_end__</code>, <code>end</code> 等</p>
<p>另外, 标准库会产生很多奇奇怪怪的 section, 处理起来很麻烦</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="libc"><a class="header" href="#libc">libc</a></h2>
<p>C 标准库有多种实现，如大多数 GNU/Linux 系统上的 <code>glibc</code>。<code>newlib</code> 是 RedHat 维护的针对嵌入式系统的 C 标准库。<code>arm-none-eabi-gcc</code> 工具链附带了 <code>newlib</code>。以及一个更轻量的变体 <code>newlib-nano</code>。位于 <code>/usr/arm-none-eabi/lib</code>：</p>
<table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody>
<tr><td><code>libc.a</code></td><td>newlib 库</td></tr>
<tr><td><code>libc_nano.a</code></td><td>newlib nano 库</td></tr>
<tr><td><code>librdimon.a</code></td><td>newlib 库 带有 semihosting</td></tr>
<tr><td><code>librdimon_nano.a</code></td><td>newlib nano 库 带有 semihosting</td></tr>
<tr><td><code>*.specs</code></td><td>在链接时使用的文件, 在链接参数里指定, 用于链接不同的库</td></tr>
</tbody></table>
<p>使用时需要实现一些桩函数（System Calls）, 除非指定了 nosys.specs 或使用 semihosting 库</p>
<table><thead><tr><th>常用的链接参数</th><th>说明</th></tr></thead><tbody>
<tr><td>无</td><td>使用 newlib 库</td></tr>
<tr><td>-specs=nano.specs</td><td>使用 newlib nano 库</td></tr>
<tr><td>-specs=nosys.specs</td><td></td></tr>
<tr><td>-nostdlib</td><td>不链接到 libc</td></tr>
</tbody></table>
<h3 id="semihosting"><a class="header" href="#semihosting">Semihosting</a></h3>
<p>半主机功能, 允许 printf 等函数输出到 openocd 终端上</p>
<ol>
<li>需要使用特定的标准库（无需打桩）</li>
<li>在程序中初始化半主机功能</li>
<li>在 openocd 中启用半主机功能</li>
</ol>
<h3 id="桩函数system-calls"><a class="header" href="#桩函数system-calls">桩函数（System Calls）</a></h3>
<p>https://sourceware.org/newlib/libc.html#Syscalls 提供了 newlib 的桩函数列表和最小实现。</p>
<p>这些桩函数并不是全都要实现。链接时 ld 会提示缺少哪些函数，这主要取决于程序中用到了 libc 的哪些功能。</p>
<h3 id="构造函数"><a class="header" href="#构造函数">构造函数</a></h3>
<p>可以给一些函数添加 <code>__attribute__((constructor))</code>，声明为构造函数。libc 会在 <code>__libc_init_array()</code> 中依次调用这些构造函数。<code>__libc_init_array()</code> 通常在 <code>Reset_Handler</code> 中执行，且先于 <code>main</code>。</p>
<p>例如：将 <code>_write</code> 实现为通过串口输出，为了保证串口可用，将初始化串口的函数声明为构造函数。</p>
<h3 id="线程安全"><a class="header" href="#线程安全">线程安全</a></h3>
<p>大多数 newlib 函数是可重入的。对于其他函数，为了保证线程安全，OS 需要在上下文切换时正确地设置 <code>_impure_ptr</code> 变量，这个变量指向 <code>struct _reent</code> 结构体，其中保存了一个线程使用标准库的状态。</p>
<p>为了允许 <code>malloc</code> 可重入，需要实现 <code>malloc_lock</code> 和 <code>malloc_unlock</code>。通常建议使用递归互斥锁实现。</p>
<h3 id="替换标准库函数"><a class="header" href="#替换标准库函数">替换标准库函数</a></h3>
<p>在自己的代码中定义与标准库函数签名相同的函数，可以替换掉标准库中对应的函数。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="bootloader"><a class="header" href="#bootloader">bootloader</a></h2>
<h3 id="bootloader-的作用"><a class="header" href="#bootloader-的作用">bootloader 的作用</a></h3>
<ul>
<li>从外部存储器（如 SPI flash）拷贝固件到可执行的区域（如 RAM）</li>
<li>解藕固件的各个部分（bootloader 和 app），通过 UART/USB/OTA 更新固件（app）</li>
<li>安全启动、验证加密签名、捕获 app 的 reboot loop 等</li>
</ul>
<h3 id="实现方法"><a class="header" href="#实现方法">实现方法</a></h3>
<ol>
<li>分割 flash，将 bootloader 和 app 定位到不同的区域</li>
</ol>
<pre><code>MEMORY
{
    bootrom (rx) : ORIGIN = 0x08000000, LENGTH = 16K
    approm (rx) : ORIGIN = 0x08004000, LENGTH = 112K
    ram (rwx) : ORIGIN = 0x20000000, LENGTH = 32K
}
</code></pre>
<ul>
<li><code>bootrom</code> 里是 bootloader 的中断向量表、text、data</li>
<li><code>approm</code> 里是 app 的中断向量表、text、data</li>
<li><code>ram</code> 是共享的</li>
</ul>
<ol start="2">
<li>在 bootloader 中引导 app</li>
</ol>
<pre><code class="language-c">int main() {
    uint32_t* p = (uint32_t*)&amp;__approm_start__;	// 获取 app 的中断向量表地址
    uint32_t msp = p[0];						// app 的 msp
    uint32_t entry = p[1];						// app 的 入口地址
    __asm(&quot;msr msp, %0;&quot; ::&quot;r&quot;(msp)); 	 		// 设置 msp
    ((void (*)())entry)();             			// 跳转到 app 的 Reset_Handler
}
</code></pre>
<ul>
<li>bootloader 先启动（因为它的中断向量在 <code>0x08000000</code>），经过 <code>Reset_Handler</code> 进入 <code>main()</code></li>
<li>在 bootloader 的 <code>main()</code> 里读 app 的中断向量表，引导 app 启动</li>
</ul>
<ol start="3">
<li>在 app 的 Reset_Handler 里重定位中断向量表，以便后续使用 app 的中断 Handler</li>
<li>bootloader 和 app 分别编译连接，可以分别下载，或者合并 bin 文件一起下载</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="openocd"><a class="header" href="#openocd">openocd</a></h3>
<pre><code class="language-sh">openocd -f interface/stlink-v2.cfg -f target/stm32f1x.cfg.bak
</code></pre>
<p>需要指定 interface 和 target，这些脚本文件在 /usr/share/openocd/scripts</p>
<p>可以在当前目录下创建 <code>openocd.cfg</code> 文件，openocd 启动时自动读取，例如：</p>
<pre><code>source [find interface/stlink.cfg]
source [find target/stm32f3x.cfg]
</code></pre>
<h3 id="gdb"><a class="header" href="#gdb">GDB</a></h3>
<pre><code class="language-shell">arm-none-eabi-gdb --tui -q build/target.elf
</code></pre>
<p>GDB 命令：</p>
<pre><code class="language-sh">target remote :3333

monitor reset init halt shutdown

load

file ./build/target.elf

b main
info b
del 断点号

c
s
n
si
finish

l
layout asm
layout reg
layout src

display 变量
x/数量/格式(x/d/c/f...)/大小(b/h/w) 地址
// 例如
x/1xw 0x08000000
x/4dh queue

Ctrl + C
q
</code></pre>
<h3 id="stm32flash"><a class="header" href="#stm32flash">stm32flash</a></h3>
<pre><code class="language-shell">stm32flash /dev/ttyACM0
stm32flash -w build/G070Test.elf -v -g 0x0 /dev/ttyACM0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lvgl"><a class="header" href="#lvgl">LVGL</a></h1>
<p>大部分内容来源于</p>
<ul>
<li>https://docs.lvgl.io/8.2/</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="硬件要求"><a class="header" href="#硬件要求">硬件要求</a></h2>
<table><thead><tr><th>项目</th><th>最低</th><th>推荐</th></tr></thead><tbody>
<tr><td>微处理器</td><td>16、32 或 64 位</td><td></td></tr>
<tr><td>时钟频率</td><td>&gt; 16MHz</td><td>&gt; 48MHz</td></tr>
<tr><td>Flash</td><td>&gt; 64kB</td><td>&gt; 180kB</td></tr>
<tr><td>RAM Static</td><td>&gt; 2kB</td><td></td></tr>
<tr><td>RAM Stack</td><td>&gt; 2kB</td><td>&gt; 8kB</td></tr>
<tr><td>RAM Heap*</td><td>&gt; 4kB</td><td>&gt; 32kB</td></tr>
<tr><td>显存</td><td>一屏，可能在MCU内部或外部</td><td></td></tr>
<tr><td>LVGL 绘制缓冲区</td><td>1 x 水平分辨率</td><td>&gt; 1/10 屏</td></tr>
</tbody></table>
<p>*指的是 LVGL 管理的堆，由<code>lv_conf.h</code> 中的 <code>LV_MEM_SIZE</code> 设定</p>
<h2 id="移植步骤"><a class="header" href="#移植步骤">移植步骤</a></h2>
<h4 id="准备工作"><a class="header" href="#准备工作">准备工作</a></h4>
<ol>
<li>
<p>从<a href="https://github.com/lvgl/lvgl">官方仓库</a>下载合适的版本，把目录命名为 <code>lvgl</code></p>
</li>
<li>
<p>把整个 <code>lvgl</code> 目录复制进项目里</p>
</li>
<li>
<p>把 <code>lvgl/lv_conf_template.h</code> 提取到 <code>lvgl</code> 目录外，与其并列，更名为 <code>lv_conf.h</code></p>
</li>
<li>
<p>编辑 <code>lv_conf.h</code>：将其中的 <code>#if 0</code> 更改为 <code>1</code> 以启用配置，根据屏幕设置 <code>LV_COLOR_DEPTH</code>。另外可以考虑设置 <code>LV_MEM_SIZE</code>、<code>LV_USE_PERF_MONITOR</code>、<code>LV_USE_MEM_MONITOR</code> 等</p>
</li>
<li>
<p>在需要使用 LVGL API 的地方引入 <code>lvgl/lvgl.h</code> 头文件</p>
</li>
<li>
<p>每 <code>x</code> 毫秒调用 <code>lv_tick_inc(x)</code> 一次。<code>1 &lt;= x &lt;= 10</code></p>
</li>
</ol>
<h4 id="主函数任务"><a class="header" href="#主函数任务">主函数/任务</a></h4>
<ol>
<li>调用 <code>lv_init()</code></li>
<li>创建绘制缓冲区：</li>
</ol>
<pre><code class="language-c">static lv_disp_draw_buf_t draw_buf;
static lv_color_t buf1[DISP_HOR_RES * DISP_VER_RES / 10];                        /*Declare a buffer for 1/10 screen size*/
lv_disp_draw_buf_init(&amp;draw_buf, buf1, NULL, DISP_HOR_RES * DISP_VER_RES / 10);  /*Initialize the display buffer.*/
</code></pre>
<p>其中 <code>DISP_HOR_RES</code> 和 <code>DISP_VER_RES</code> 是屏幕分辨率</p>
<ol start="3">
<li>实现一个用于把绘制缓冲区中数据推送到屏幕上的函数，例如：</li>
</ol>
<pre><code class="language-c">void my_disp_flush(lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * color_p)
{
    int32_t x, y;
    /*It's a very slow but simple implementation.
     *`set_pixel` needs to be written by you to a set pixel on the screen*/
    for(y = area-&gt;y1; y &lt;= area-&gt;y2; y++) {
        for(x = area-&gt;x1; x &lt;= area-&gt;x2; x++) {
            set_pixel(x, y, *color_p);
            color_p++;
        }
    }

    lv_disp_flush_ready(disp);         /* Indicate you are ready with the flushing*/
}
</code></pre>
<p>然后注册这个函数：</p>
<pre><code class="language-c">static lv_disp_drv_t disp_drv;        /*Descriptor of a display driver*/
lv_disp_drv_init(&amp;disp_drv);          /*Basic initialization*/
disp_drv.flush_cb = my_disp_flush;    /*Set your driver function*/
disp_drv.draw_buf = &amp;draw_buf;          /*Assign the buffer to the display*/
disp_drv.hor_res = DISP_HOR_RES;   /*Set the horizontal resolution of the display*/
disp_drv.ver_res = DISP_VER_RES;   /*Set the vertical resolution of the display*/
lv_disp_drv_register(&amp;disp_drv);      /*Finally register the driver*/
</code></pre>
<ol start="4">
<li>如果需要的话，实现用于输入设备的函数：</li>
</ol>
<pre><code class="language-c">void my_touchpad_read(lv_indev_t * indev, lv_indev_data_t * data)
{
    /*`touchpad_is_pressed` and `touchpad_get_xy` needs to be implemented by you*/
    if(touchpad_is_pressed()) {
      data-&gt;state = LV_INDEV_STATE_PRESSED;
      touchpad_get_xy(&amp;data-&gt;point.x, &amp;data-&gt;point.y);
    } else {
      data-&gt;state = LV_INDEV_STATE_RELEASED;
    }
 
}
</code></pre>
<p>并且注册输入设备：</p>
<pre><code class="language-c">static lv_indev_drv_t indev_drv;           /*Descriptor of a input device driver*/
lv_indev_drv_init(&amp;indev_drv);             /*Basic initialization*/
indev_drv.type = LV_INDEV_TYPE_POINTER;    /*Touch pad is a pointer-like device*/
indev_drv.read_cb = my_touchpad_read;      /*Set your driver function*/
lv_indev_drv_register(&amp;indev_drv);         /*Finally register the driver*/
</code></pre>
<ol start="5">
<li>在死循环中每隔几毫秒调用 <code>lv_timer_handler()</code> 函数，它会处理屏幕显示、输入设备、动画等</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="haskell"><a class="header" href="#haskell">Haskell</a></h1>
<p>大部分内容来源于</p>
<ul>
<li>《The Little Schemer》</li>
<li>https://github.com/MnO2/learnyouahaskell-zh</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="用递归代替循环"><a class="header" href="#用递归代替循环">用递归代替循环</a></h2>
<p>技巧：将循环中所需的变量，转化成递归函数所用的参数</p>
<p>一种比较通用的编写思路：一般性递归</p>
<h2 id="自然数公理"><a class="header" href="#自然数公理">自然数公理</a></h2>
<p>首先有后继 <code>succ</code> 和前驱 <code>prev</code> 函数。于是加法、减法、乘法、幂运算可以定义为：</p>
<pre><code class="language-haskell">add 0 b = b
add a b = succ $ add (prev a) b

minus a 0 = a
minus a b = prev $ minus a (prev b)

times a 0 = 0
times a b = add a $ times a (prev b)

mi a 0 = 1
mi a b = times a $ mi a (prev b)
</code></pre>
<p>定义小于关系：</p>
<pre><code class="language-haskell">less a 0 = False
less 0 b = True
less a b = less (prev a) (prev b)
</code></pre>
<p>在此基础上，可以定义整数除法：</p>
<pre><code class="language-haskell">divd a b
  | less a b = 0
  | otherwise = succ $ divd (minus a b) b
</code></pre>
<h2 id="停机问题"><a class="header" href="#停机问题">停机问题</a></h2>
<p>假设有函数 <code>willstop</code> 可以判断任意函数是否停机：</p>
<pre><code class="language-haskell">willstop f = ...
</code></pre>
<p>若函数 <code>f</code> 可以停机，则返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p>那么可以构造如下函数：</p>
<pre><code class="language-haskell">f = willstop f &amp;&amp; deadloop
  where
    deadloop = deadloop
</code></pre>
<p>不妨假设 <code>willstop f</code> 为 <code>True</code>，即 <code>f</code> 可以停机。那么在调用 <code>f</code> 时，它会陷入死循环 <code>deadloop</code>，无法停机，矛盾。</p>
<p>假设 <code>willstop f</code> 为 <code>False</code>，即 <code>f</code> 不能停机。那么在调用 <code>f</code> 时，由于短路求值，<code>deadloop</code> 不会被执行，直接返回结果，能够停机，矛盾。</p>
<p>因此 <code>willstop</code> 不可能被实现，停机问题不能被判定。</p>
<h2 id="y-组合子"><a class="header" href="#y-组合子">Y 组合子</a></h2>
<p>在定义递归函数时，通常来说我们不能将它定义为匿名函数，因为这个函数需要调用自身，也就需要一个名字。而在无类型 lambda 演算中我们无法给函数命名，为了实现递归函数就需要一个特殊的技巧，就是 Y 组合子。Y 组合子是一个函数，它作用在一个匿名函数上，可以将其转换成一个递归函数。</p>
<p>如果对于函数 $f$，有 $f\ g = g$，那么就说 $g$ 是 $f$ 的不动点。Y 组合子具有一个特殊的性质：$f\ (Y\ f)=(Y\ f)$，即它可以计算出函数的不动点。</p>
<p>haskell 中定义 Y 组合子：</p>
<pre><code class="language-haskell">y f = let x = f x in x
</code></pre>
<p>递归形式的阶乘函数：</p>
<pre><code class="language-haskell">fact 1 = 1
fact n = n * fact (n - 1)
</code></pre>
<p>去掉其中的递归，进而可以定义：</p>
<pre><code class="language-haskell">fact' f 1 = 1
fact' f n = n * f (n - 1)
</code></pre>
<p>注意到 <code>fact</code> 是 <code>fact'</code> 的不动点。即 <code>fact' fact = fact</code>。于是将 Y 组合子作用到 <code>fact'</code> 上，就可以得到阶乘函数，即 <code>y fact' = fact</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="命令"><a class="header" href="#命令">:命令</a></h2>
<pre><code class="language-haskell">ghci&gt; :l test 		-- 装载当前目录下的.hs
ghci&gt; :m Data.Map 	-- 装载模块
ghci&gt; :t 1 			-- 检查类型
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="list"><a class="header" href="#list">List</a></h2>
<p>一个 list 只能装同类型的内容</p>
<pre><code class="language-haskell">[1,2,3,4]

['h','e','l','l','o']
&quot;Hello&quot;		-- 实质上就是上面那个的语法糖

[]
[[],[]]
[[3],[4,2]]

-- 合并（如果左边的 list 很长，性能会不好）
[1,2] ++ [3,4] ++ []
&quot;hello&quot; ++ &quot;world&quot;

-- 插入
'A':&quot;BCDEF&quot;
1:[2,3,4]
1:2:3:4:[]

-- 索引
&quot;steam&quot; !! 4
[1,2,3] !! 0

-- 比较：先比较第一个元素，如果相等则比较下一个
[3,2,1] &gt; [1,2,3]
</code></pre>
<p>一些函数</p>
<pre><code class="language-haskell">head [1,2,3]	-- 1
last [1,2,3]	-- 3
tail [1,2,3]	-- [2,3]
init [1,2,3]	-- [1,2]
-- 上面这些不能对空列表使用

length [1,2,3]
null [1]	-- False
null []		-- True

reverse [1,2,3]		-- [3,2,1] 反转

take 2 [1,2,3]		-- [1,2] 取出前n个元素
drop 2 [1,2,3]		-- [3] 删除前n个元素

minimum [2,3,1]		-- 3
maximum	[2,3,1]		-- 1
sum [1,2,3]			-- 6 求和
product [1,2,3]		-- 6 求积

elem 4 [1,2,3]	-- False 判断是否包含

-- 区间
[1..20]
[1,3..19]	-- 指明前两项
[20,19..1]	-- 倒序
[1..]		-- 无限长
['a'..'z']
['D'..'J']

replicate 3 10	-- [10,10,10]
repeat 4 		-- 返回无限重复该元素的list
cycle list 		-- 返回无限重复的这个list
</code></pre>
<h3 id="list-comprehension"><a class="header" href="#list-comprehension">List Comprehension</a></h3>
<pre><code class="language-haskell">[x*2 | x &lt;- [1..10], x*2 &gt;= 12]
-- 限制条件，由逗号分隔

boomBangs xs = [ if x &lt; 10 then &quot;BOOM!&quot; else &quot;BANG!&quot; | x &lt;- xs, odd x]

[ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11]]

[ adj ++ &quot; &quot; ++ n | adj &lt;- [&quot;happy&quot;, &quot;sad&quot;], n &lt;- [&quot;hobo&quot;, &quot;pope&quot;]]

length' xs = sum [1 | _ &lt;- xs]	-- 取出，但是不使用

xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
[ [ x | x &lt;- xs, even x ] | xs &lt;- xxs]	-- 嵌套

[ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2, a+b+c == 24]

-- 模式匹配
let xs = [(1,3),(2,4),(5,6)]
[a+b | (a,b) &lt;- xs]
</code></pre>
<h2 id="tuple"><a class="header" href="#tuple">Tuple</a></h2>
<p>元组，其中各元素的类型的数量必须是确定的，类似于结构体</p>
<p>list 只能装同类型元素，数量任意
tuple 可以装不同类型的元素，数量必须确定</p>
<pre><code class="language-haskell">-- 这是两个不同类型的 tuple
(1,2,3)
(1,2)
</code></pre>
<p>含有两个元素的tuple称为序对</p>
<pre><code class="language-haskell">fst (&quot;hello&quot;, True) -- 取序对的第一个元素
snd (8, 'a')		-- 取序对的第二个元素

zip [1 .. 5] [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]	-- 两两配对成序对
-- 得到 [(1,&quot;one&quot;),(2,&quot;two&quot;),(3,&quot;three&quot;),(4,&quot;four&quot;),(5,&quot;five&quot;)]
</code></pre>
<hr />
<h2 id="类型"><a class="header" href="#类型">类型</a></h2>
<pre><code class="language-haskell">:: -- 两个冒号，用于说明类型
'a' :: Char
&quot;HELLO!&quot; :: [Char]		-- [Char] 也可以写成 String
(True, 'a') :: (Bool, Char)

removeNonUppercase :: [Char] -&gt; [Char]						-- 函数的类型声明
removeNonUppercase st = [ c | c&lt;-st, c `elem` ['A'..'Z']]

addThree :: Int -&gt; Int -&gt; Int -&gt; Int    -- 注意这里的写法
addThree x y z = x + y + z
</code></pre>
<h2 id="类型变量"><a class="header" href="#类型变量">类型变量</a></h2>
<pre><code class="language-haskell">head :: [a] -&gt; a
fst :: (a, b) -&gt; a
</code></pre>
<p>这里的 a 是类型变量，类似其他语言中的泛型。</p>
<h2 id="类型类"><a class="header" href="#类型类">类型类</a></h2>
<p>类似于 java 中的接口</p>
<pre><code class="language-haskell">(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool
</code></pre>
<p>=&gt; 左侧的部分称为类型约束，a 属于类型类 Eq，可判断相等性</p>
<table><thead><tr><th>类型类</th><th>说明</th><th>相关的函数</th></tr></thead><tbody>
<tr><td>Eq</td><td>可判断相等性</td><td></td></tr>
<tr><td>Ord</td><td>可判断顺序</td><td>compare</td></tr>
<tr><td>Show</td><td>可以转为字符串</td><td>show</td></tr>
<tr><td>Read</td><td>可以由字符串转换得到</td><td>read</td></tr>
<tr><td>Enum</td><td>可枚举，可在 Range 中使用</td><td>succ    pred</td></tr>
<tr><td>Bounded</td><td>有上限和下限</td><td>maxBound  minBound</td></tr>
<tr><td>Num</td><td>数字</td><td>+  -  *</td></tr>
<tr><td>Integral</td><td>整数，包含 Int 和 Interger</td><td></td></tr>
<tr><td>Floating</td><td>浮点类型， 包含 Float 和 Double</td><td></td></tr>
</tbody></table>
<pre><code class="language-haskell">-- 使用 read 时注意写类型注释
read &quot;1&quot; :: Int
read &quot;[1,2,3]&quot; :: [Int]
</code></pre>
<hr />
<h2 id="自定义型别"><a class="header" href="#自定义型别">自定义型别</a></h2>
<pre><code class="language-haskell">data Maybe a = Nothing | Just a
</code></pre>
<p>型别构造子 Maybe</p>
<p>值构造子 Nothing
值构造子 Just</p>
<p>值构造子事实上是个函数</p>
<blockquote>
<p>带有参数的型别构造子，类似于一种泛型的容器</p>
</blockquote>
<pre><code class="language-haskell">data Point = Point Float Float deriving (Show, Eq)
data Shape = Circle Point Float | Rectangle Point Point deriving (Show, Eq)
</code></pre>
<h3 id="record-syntax"><a class="header" href="#record-syntax">Record Syntax</a></h3>
<pre><code class="language-haskell">data Car = Car
  { company :: String,
    model :: String,
    year :: Int
  }
  deriving (Show)
</code></pre>
<p>以这种形式创建值构造子，就会自动创建出函数 <code>company</code>，<code>model</code> 等。并且可以以这种形式创建：</p>
<pre><code class="language-haskell">Car {company=&quot;Ford&quot;, model=&quot;Mustang&quot;, year=1967}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="if-then-else"><a class="header" href="#if-then-else">if then else</a></h2>
<p>else 是必不可少的，因为这是一个<strong>表达式</strong>，会返回一个值，而非一种流程控制</p>
<pre><code class="language-haskell">doubleSmallNum x = if x &gt; 100 then x else x*2
</code></pre>
<hr />
<h2 id="let-in"><a class="header" href="#let-in">let in</a></h2>
<p><code>let [bindings] in [expressions]</code> <strong>表达式</strong>。bindings 中定义的常量、函数仅在 expression 中可见。</p>
<blockquote>
<p>模式匹配、Guard、where属于语法结构，只能在特定的地方使用。而<strong>表达式</strong>可以用在任意位置</p>
</blockquote>
<pre><code class="language-haskell">cylinder :: (RealFloat a) =&gt; a -&gt; a -&gt; a  
cylinder r h = 
    let sideArea = 2 * pi * r * h  
        topArea = pi * r ^2  
    in  sideArea + 2 * topArea
    
[let square x = x * x in (square 5, square 3, square 2)]  
-- [(25,9,4)]
</code></pre>
<p>在 List 中使用 let</p>
<pre><code class="language-haskell">calcBmis :: (RealFloat a) =&gt; [(a, a)] -&gt; [a]  
calcBmis xs = [bmi | (w, h) &lt;- xs, let bmi = w / h ^ 2, bmi &gt;= 25.0]
</code></pre>
<p>这里省略了 in</p>
<hr />
<h2 id="case-of"><a class="header" href="#case-of">Case of</a></h2>
<p>case <strong>表达式</strong>，类似模式匹配</p>
<pre><code class="language-haskell">describeList :: [a] -&gt; String  
describeList xs = &quot;The list is &quot; ++ case xs of [] -&gt; &quot;empty.&quot;  
                                               [x] -&gt; &quot;a singleton list.&quot;   
                                               xs -&gt; &quot;a longer list.&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="函数-2"><a class="header" href="#函数-2">函数</a></h2>
<pre><code class="language-haskell">-- 定义
a = &quot;hello&quot;		-- 没有参数的函数，也称作定义，值不可修改
doubleMe x = x + x
doubleUs x y = x*2 + y*2

-- 调用
doubleMe 3
doubleUs 3 4
3 `doubleUs` 4	-- 前缀函数以中缀形式调用，凡是有两个参数的函数都可以这样做，定义函数时也可以用
(+) 3 4			-- 中缀函数以前缀形式调用
</code></pre>
<p>函数调用具有最高的优先级</p>
<p>函数名里可以加单引号，没有任何特殊意义。</p>
<hr />
<h2 id="模式匹配-2"><a class="header" href="#模式匹配-2">模式匹配</a></h2>
<pre><code class="language-haskell">factorial :: (Integral a) =&gt; a -&gt; a   
factorial 0 = 1   
factorial n = n * factorial (n - 1)  
</code></pre>
<p>对 Tuple 使用</p>
<pre><code class="language-haskell">addVectors :: (Num a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)   
addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)

third :: (a, b, c) -&gt; c   
third (_, _, z) = z  
</code></pre>
<p>对 List 使用</p>
<pre><code class="language-haskell">tell :: (Show a) =&gt; [a] -&gt; String
tell [] = &quot;The list is empty&quot;
tell (x:[]) = &quot;The list has one element: &quot; ++ show x
tell (x:y:[]) = &quot;The list has two elements: &quot; ++ show x ++ &quot; and &quot; ++ show y
tell (x:y:_) = &quot;This list is long. The first two elements are: &quot; ++ show x ++ &quot; and &quot; ++ show y
</code></pre>
<p>as模式：在按模式分割东西时仍保留对其整体的引用</p>
<pre><code class="language-haskell">capital :: String -&gt; String
capital &quot;&quot; = &quot;Empty string, whoops!&quot;
capital all@(x:xs) = &quot;The first letter of &quot; ++ all ++ &quot; is &quot; ++ [x]
</code></pre>
<h2 id="guard"><a class="header" href="#guard">Guard</a></h2>
<pre><code class="language-haskell">bmiTell :: (RealFloat a) =&gt; a -&gt; String  
bmiTell bmi  
    | bmi &lt;= 18.5 = &quot;You're underweight, you emo, you!&quot;  
    | bmi &lt;= 25.0 = &quot;You're supposedly normal. Pffft, I bet you're ugly!&quot;  
    | bmi &lt;= 30.0 = &quot;You're fat! Lose some weight, fatty!&quot;  
    | otherwise   = &quot;You're a whale, congratulations!&quot;
</code></pre>
<p>模式匹配和Guard可以混合使用</p>
<h3 id="where"><a class="header" href="#where">where</a></h3>
<pre><code class="language-haskell">bmiTell :: (RealFloat a) =&gt; a -&gt; a -&gt; String
bmiTell weight height
    | bmi &lt;= skinny = &quot;You're underweight, you emo, you!&quot;
    | bmi &lt;= normal = &quot;You're supposedly normal. Pffft, I bet you're ugly!&quot;
    | bmi &lt;= fat    = &quot;You're fat! Lose some weight, fatty!&quot;
    | otherwise     = &quot;You're a whale, congratulations!&quot;
    where bmi = weight / height ^ 2
          skinny = 18.5
          normal = 25.0
          fat = 30.0
</code></pre>
<p>where 中定义的量只在本函数内可见。where 中可以使用模式匹配，上例可以改成：</p>
<pre><code class="language-haskell">...  
where bmi = weight / height ^ 2  
      (skinny, normal, fat) = (18.5, 25.0, 30.0)
</code></pre>
<p>where 中可以定义函数，甚至可以嵌套</p>
<pre><code class="language-haskell">calcBmis :: (RealFloat a) =&gt; [(a, a)] -&gt; [a]  
calcBmis xs = [bmi w h | (w, h) &lt;- xs] 
    where bmi weight height = weight / height ^ 2
</code></pre>
<hr />
<h2 id="柯里化和不全调用"><a class="header" href="#柯里化和不全调用">柯里化和不全调用</a></h2>
<pre><code class="language-haskell">compareWithHundred :: (Num a, Ord a) =&gt; a -&gt; Ordering
compareWithHundred = compare 100

divideByTen :: (Floating a) =&gt; a -&gt; a
divideByTen = (/10)		-- 中缀函数的不全调用
</code></pre>
<h2 id="高阶函数"><a class="header" href="#高阶函数">高阶函数</a></h2>
<pre><code class="language-haskell">applyTwice :: (a -&gt; a) -&gt; a -&gt; a  
applyTwice f x = f (f x)

zipWith' :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]  
zipWith' _ [] _ = []  
zipWith' _ _ [] = []  
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys

flip' :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c  
flip' f y x = f x y
</code></pre>
<h3 id="map--filter--takewhile"><a class="header" href="#map--filter--takewhile">map  filter  takeWhile</a></h3>
<pre><code class="language-haskell">sum (takeWhile (&lt;10000) (filter odd (map (^2) [1..]))) -- 找出所有小于 10000，且同时为奇数和平方数的数字，求和
</code></pre>
<p>以 1 到 100 之间的所有数作为起始数，有多少 Collatz 序列的长度大于15</p>
<pre><code class="language-haskell">collatzNext :: Integral a =&gt; a -&gt; a
collatzNext x
  | odd x = 3 * x + 1
  | otherwise = div x 2

getCollatz :: Integral a =&gt; a -&gt; [a]
getCollatz 1 = [1]
getCollatz x = x : getCollatz (collatzNext x)

length(filter (&gt;15) (map length (map getCollatz [1..100])))
</code></pre>
<hr />
<h2 id="lambda"><a class="header" href="#lambda">lambda</a></h2>
<p>匿名函数 <code>\参数 -&gt; 表达式</code>.</p>
<pre><code class="language-haskell">map (\x -&gt; x*x) [1..10]
zipWith (\x y -&gt; x*y) [1..10] [2..11]

-- 可以使用模式匹配
filter (\(x,y) -&gt; x &lt; y) [(x,y) | x &lt;- [1..5], y &lt;- [1..5]]
</code></pre>
<p>在 lambda 中使用模式匹配时仅能使用一个模式，匹配失败就会导致运行时错误</p>
<hr />
<h2 id=""><a class="header" href="#">$</a></h2>
<pre><code class="language-haskell">-- 定义
($) :: (a -&gt; b) -&gt; a -&gt; b  
f $ x = f x

-- 用于替代括号
sqrt (1 + 2 + 3)
sqrt $ 1 + 2 + 3

-- 用于调用函数
map ($ 3) [(4+),(10*),(^2),sqrt]
</code></pre>
<hr />
<h2 id="函数复合"><a class="header" href="#函数复合">函数复合</a></h2>
<pre><code class="language-haskell">-- 定义
(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c  
f . g = \x -&gt; f (g x)

map (negate . abs) [5,-3,-6,7,-3,2,-19,24]

sum (takeWhile (&lt;10000) (filter odd (map (^2) [1..])))
sum . takeWhile (&lt;10000) . filter odd . map (^2) $ [1..]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="fold"><a class="header" href="#fold">fold</a></h2>
<p>左折叠 <code>foldl</code></p>
<pre><code class="language-haskell">foldl (+) 0 [1..10]
-- ((0+1) + 2) + 3 ...
</code></pre>
<p>右折叠 <code>foldr</code></p>
<pre><code class="language-haskell">foldr (-) 0 [1..10]
-- ... 8 - (9 - (10 - 0))
</code></pre>
<p><code>foldl1</code> 与 <code>foldr1</code>：无需提供初始值，直接对 List 内元素操作。要求 List 非空。</p>
<p><code>scanl</code> 和 <code>scanr</code>：与 <code>foldl</code> 和 <code>foldr</code> 相似，但是记录所有中间值</p>
<p><code>scanl1</code> 和 <code>scanr1</code>：与 <code>foldl1</code> 和 <code>foldr1</code> 相似，但是记录所有中间值</p>
<h2 id="datalist"><a class="header" href="#datalist">Data.List</a></h2>
<p>intersperse 取一个元素与 List 作参数，并将该元素置于 List 中每对元素的中间</p>
<p>intercalate 取两个 List 作参数。它会将第一个 List 交叉插入第二个 List 中间</p>
<p>transpose 函数把一组 List 的 List 看作二维矩阵，做转置操作</p>
<pre><code class="language-haskell">ghci&gt; transpose [[1,2,3],[4,5,6],[7,8,9]]  
[[1,4,7],[2,5,8],[3,6,9]]  
</code></pre>
<p>foldl' 和 foldl1' 是它们各自惰性实现的严格版本。有助于避免处理长 List 时堆栈溢出的问题</p>
<hr />
<p>concat 把一组 List 连接为一个 List</p>
<p>concatMap 函数先 map 一个 List 再做 concat</p>
<pre><code class="language-haskell">ghci&gt; concat [[3,4,5],[2,3,4],[2,1,1]]  
[3,4,5,2,3,4,2,1,1]
ghci&gt; concat [&quot;123&quot;, &quot;ree&quot;]

</code></pre>
<hr />
<p>and 和 or 取一组布尔值构成的 List，对其全体进行与/或运算</p>
<p>any 和 all 检查 List 中元素是否符合条件</p>
<pre><code class="language-haskell">any (==4) [1..5]
all (&gt;4) [5..9]
</code></pre>
<hr />
<p>iterate 取一个函数和一个值作参数。它会用该值去调用该函数并用所得的结果再次调用该函数，产生一个无限的 List</p>
<pre><code class="language-haskell">ghci&gt; take 10 $ iterate (*2) 1  
[1,2,4,8,16,32,64,128,256,512]
</code></pre>
<hr />
<p>splitAt 使 List 在特定的位置断开。返回一个包含两个 List 的二元组</p>
<pre><code class="language-haskell">ghci&gt; splitAt 3 &quot;heyman&quot;  
(&quot;hey&quot;,&quot;man&quot;)
</code></pre>
<p>dropWhile 扔掉 List 中符合条件的元素。一旦限制条件返回 <code>False</code>，它就返回 List 的余下部分</p>
<pre><code class="language-haskell">ghci&gt; dropWhile (&lt;3) [1,2,2,2,3,4,5,4,3,2,1]  
[3,4,5,4,3,2,1]
</code></pre>
<p>span 和 break 在一定条件的位置断开 List</p>
<pre><code class="language-haskell">ghci&gt; break (==4) [1,2,3,4,5,6,7]  
([1,2,3],[4,5,6,7])  
ghci&gt; span (/=4) [1,2,3,4,5,6,7]  
([1,2,3],[4,5,6,7])
</code></pre>
<p>partition 取一个限制条件和 List 作参数，返回两个 List，第一个 List 中包含所有符合条件的元素，而第二个 List 中包含余下的</p>
<hr />
<p>sort 可以排序一个 List</p>
<p>group 取一个 List 作参数，并将其中相邻并相等的元素各自归类，组成一个个子 List</p>
<pre><code class="language-haskell">ghci&gt; group [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]  
[[1,1,1,1],[2,2,2,2],[3,3],[2,2,2],[5],[6],[7]]
</code></pre>
<hr />
<p>inits 和 tails</p>
<pre><code class="language-haskell">ghci&gt; inits &quot;w00t&quot;
[&quot;&quot;,&quot;w&quot;,&quot;w0&quot;,&quot;w00&quot;,&quot;w00t&quot;]
ghci&gt; tails &quot;w00t&quot;
[&quot;w00t&quot;,&quot;00t&quot;,&quot;0t&quot;,&quot;t&quot;,&quot;&quot;]
</code></pre>
<p>isInfixOf 从一个 List 中搜索一个子 List，若该 List 包含子 List，则返回 <code>True</code></p>
<p>isPrefixOf 与 isSuffixOf 分别检查一个 List 是否以某子 List 开头或者结尾.</p>
<hr />
<p>elem 和 notElem</p>
<p>elemIndex 与 <code>elem</code> 相似，只是它返回的不是布尔值，它只是'可能' (Maybe)返回我们找的元素的索引，若这一元素不存在，就返回 <code>Nothing</code></p>
<p>elemIndices 与 <code>elemIndex</code> 相似，但它找出所有符合的元素的索引，组成一个 List</p>
<p>find 取一个 List 和限制条件作参数，并返回首个符合该条件的元素，而这个元素是个 <code>Maybe</code> 值</p>
<pre><code class="language-haskell">ghci&gt; find (&gt;4) [1,2,3,4,5,6]  
Just 5  
ghci&gt; find (&gt;9) [1,2,3,4,5,6]  
Nothing  
ghci&gt; :t find  
find :: (a -&gt; Bool) -&gt; [a] -&gt; Maybe a
</code></pre>
<p>findIndex 和 findIndices</p>
<hr />
<p><code>zip3</code>,<code>zip4</code>...,和 <code>zipWith3</code>, <code>zipWith4</code>...直到 7</p>
<hr />
<p>lines unlines</p>
<p>words unwords</p>
<hr />
<p>delete</p>
<p>List 差集操作 </p>
<pre><code class="language-haskell">ghci&gt; [1..10] \\ [2,5,9]
[1,3,4,6,7,8,10]
</code></pre>
<p>union 并集</p>
<p>intersect 交集</p>
<p>insert 插入一个元素，置于首个大于等于它的元素之前</p>
<hr />
<p>nubBy，deleteBy，unionBy，intersectBy 和 groupBy，取一个函数作参数来判定相等性</p>
<p>sortBy，insertBy，maximumBy 和 minimumBy 都取一个函数来比较两个元素的大小</p>
<hr />
<h2 id="datachar"><a class="header" href="#datachar">Data.Char</a></h2>
<p>处理字符</p>
<h2 id="datamap"><a class="header" href="#datamap">Data.Map</a></h2>
<p>处理 Map（键值对）</p>
<p>fromList 从 List 构建 Map</p>
<h2 id="dataset"><a class="header" href="#dataset">Data.Set</a></h2>
<p>处理 Set</p>
<p>fromList 从 List 构建 Set</p>
<p>null，size，member，empty，singleton，insert，delete</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="装载模块"><a class="header" href="#装载模块">装载模块</a></h2>
<pre><code class="language-haskell">import Data.List
import Data.List (nub, sort) -- 调用指定函数
import Data.List hiding (nub) -- 排除指定函数

-- 然后直接通过函数名调用
nub [1,2,3]

import qualified Data.Map -- 防止重名
Data.Map.filter -- 调用函数

import qualified Data.Map as M -- 对模块起别名
M.filter -- 用别名调用
</code></pre>
<p>Prelude 模块会自动装载，其中已经包含了一些常用函数</p>
<h2 id="建立自己的模块"><a class="header" href="#建立自己的模块">建立自己的模块</a></h2>
<pre><code class="language-haskell">module Shapes
( Point(..)
, Shape(..)
, surface
, nudge
, baseCircle
, baseRect
) where

...
</code></pre>
<p>在模块的开头声明要导出的型别、函数等</p>
<p>可以通过只导出部分函数、不导出型别等手段实现一种封装</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verilog"><a class="header" href="#verilog">Verilog</a></h1>
<p>大部分内容来源于</p>
<ul>
<li>https://www.runoob.com/w3cnote/verilog-tutorial.html</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="数值种类"><a class="header" href="#数值种类">数值种类</a></h3>
<pre><code class="language-verilog">0, 1, x ,z
</code></pre>
<h3 id="整数数值的表示法"><a class="header" href="#整数数值的表示法">整数数值的表示法</a></h3>
<pre><code class="language-verilog">// 位宽 ' 进制 数值
4'b 1011
8'b 0100_1111
32'h 3022_c0de
'd 100
-6'd15
</code></pre>
<h3 id="数据类型-1"><a class="header" href="#数据类型-1">数据类型</a></h3>
<pre><code class="language-verilog">wire a; // 线网

reg b;  // 寄存器

reg [3:0] c; // 向量
wire [7:0] bus; 
reg [0:31] data;

wire [9:0] data_low = data[0:9];
bus = {4'b 0110, c[3:0]}; // 大括号组合成新向量

// 整数,实数,时间
// 数组
// 参数(常量)
// 字符串
</code></pre>
<h3 id="运算符"><a class="header" href="#运算符">运算符</a></h3>
<pre><code class="language-verilog">+ 
-
*
/
** //求幂
%  //取模

&gt;
&lt;
&gt;=
&lt;=

==
!=
=== //全等
!== //非全等
// 全等/非全等可以比较x和z

//逻辑运算符
&amp;&amp;
||
!

//按位操作符
~
&amp;
|
^  //异或
~^ //同或

//归约操作符(单目操作符),对向量操作数逐位进行操作, 最终产生一个 1bit 结果
&amp;  //归约与
~&amp; //归约与非
|  //归约或
~| //归约或非
^  //归约异或
~^ //归约同或

&lt;&lt;  //左移
&gt;&gt;  //右移
&lt;&lt;&lt; //算术左移
&gt;&gt;&gt; //算术右移

//拼接操作符
{,}
B = 4'b 0101;
A = {4'b 1110, B};
T = {8{B}}       // 指定位宽
H = {32'{1'b0}}; // 指定位宽

//三目运算符
?:
</code></pre>
<h3 id="编译指令"><a class="header" href="#编译指令">编译指令</a></h3>
<pre><code class="language-verilog">`define DATA_DW 32
`undef DATA_DW
`ifdef
`ifndef
`elsif
`else
`endif

`include &quot;header.v&quot;

`timescale 1ns/1ns
</code></pre>
<h3 id="连续赋值语句"><a class="header" href="#连续赋值语句">连续赋值语句</a></h3>
<pre><code class="language-verilog">assign Cout = A &amp; B;
</code></pre>
<h3 id="过程结构语句"><a class="header" href="#过程结构语句">过程结构语句</a></h3>
<pre><code class="language-verilog">//从最开始的时候执行
initial begin
    bi = 1 ;
    #70 ; bi = 0 ;        //absolute 70ns
    #20 ; bi = 1 ;        //absolute 90ns
end

//无限循环执行
always begin
    #10;
    if ($time &gt;= 1000) begin
        $finish ;
    end
end

//过程性赋值是在 initial 或 always 语句块里的赋值，赋值对象是寄存器、整数、实数等类型。
//阻塞赋值顺序执行
//非阻塞赋值并行执行

always @(clk) q &lt;= d ;
always @(posedge clk) q &lt;= d ;
always @(negedge clk) q &lt;= d ;
always @(posedge clk, negedge rstn) begin end
always @(*) begin end // 对语句块中所有变量敏感

//并行块
initial fork
    #5 ai_paral = 4'd5 ;    //at 5ns
    #5 bi_paral = 4'd8 ;    //at 5ns
join

//顺序块和并行块可以嵌套
//可以给语句块命令，用于从外部引用变量，或终止执行
</code></pre>
<h3 id="流程控制"><a class="header" href="#流程控制">流程控制</a></h3>
<pre><code class="language-verilog">if(en) begin
    if(sel == 2'b1) begin
        sout = p1s ;
    end
    else begin
        sout = p0 ;
    end
end

case(sel)
    2'b00: begin      
        sout_t = p0 ;
    end
    2'b01: sout_t = p1 ;
    2'b10: sout_t = p2 ;
    default: sout_t = p3 ;
endcase

while (condition) begin
    …
end

for(initial_assignment; condition ; step_assignment) begin
    …
end

repeat (loop_times) begin
    …
end

forever begin
    …
end
</code></pre>
<h3 id="赋值"><a class="header" href="#赋值">赋值</a></h3>
<pre><code class="language-verilog">assign
deassign
force
release
</code></pre>
<h3 id="实例化"><a class="header" href="#实例化">实例化</a></h3>
<pre><code class="language-verilog">generate
// 层次访问
// 带参数例化
</code></pre>
<h3 id="函数-3"><a class="header" href="#函数-3">函数</a></h3>
<h3 id="任务"><a class="header" href="#任务">任务</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="latex"><a class="header" href="#latex">LaTeX</a></h1>
<p>大部分内容来源于</p>
<ul>
<li>https://github.com/CTeX-org/lshort-zh-cn</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h4 id="命令控制序列"><a class="header" href="#命令控制序列">命令（控制序列）</a></h4>
<p>两种形式：</p>
<ol>
<li>反斜线 + 一串字母 <code>\LaTeX</code></li>
<li>反斜线 + 单个符号 <code>\$</code></li>
</ol>
<p>命令可以接收一些参数，必选参数以<code>{}</code>包裹，可选参数以<code>[]</code>包裹</p>
<h5 id="环境"><a class="header" href="#环境">环境</a></h5>
<p>用以令一些效果在局部生效，或是生成特殊的文档元素，用法为：</p>
<pre><code class="language-latex">\begin{环境名}[可选参数]{必选参数}
...
\end{环境名}
</code></pre>
<h5 id="分组"><a class="header" href="#分组">分组</a></h5>
<p>为限制命令的作用范围，可以用一对花括号<code>{}</code>创建分组。环境隐式地创建了分组。</p>
<h5 id="源代码结构"><a class="header" href="#源代码结构">源代码结构</a></h5>
<pre><code class="language-latex">\documentclass{文档类}
% 导言区
\begin{document}
% 正文内容
\end{document}
% 此后内容会被忽略
</code></pre>
<p>在导言区中常会使用 <code>\usepackage</code> 命令调用宏包，还会进行文档的全局设置</p>
<h4 id="文档类"><a class="header" href="#文档类">文档类</a></h4>
<p><code>\documentclass[可选参数]{文档类}</code></p>
<table><thead><tr><th>文档类</th><th>说明</th></tr></thead><tbody>
<tr><td>article</td><td>文章格式的文档类，广泛用于科技论文、报告、说明文档等</td></tr>
<tr><td>report</td><td>长篇报告格式的文档类，具有章节结构，用于综述、长篇论文、简单的书籍等</td></tr>
<tr><td>book</td><td>书籍文档类，包含章节结构和前言、正文、后记等结构</td></tr>
<tr><td>proc</td><td>基于 article 文档类的一个简单的学术文档模板</td></tr>
<tr><td>slides</td><td>幻灯格式的文档类，使用无衬线字体</td></tr>
<tr><td>minimal</td><td>一个极其精简的文档类，只设定了纸张大小和基本字号，用作代码测试的最小工作示例</td></tr>
</tbody></table>
<p>article, report, book 统称标准文档类
支持中文排版的： ctexart / ctexrep / ctexbook
其他：moderncv / beamer</p>
<table><thead><tr><th>可选参数</th><th>说明</th><th>默认值</th></tr></thead><tbody>
<tr><td>10pt<br />...</td><td>指定文档的基本字号</td><td>10pt</td></tr>
<tr><td>a4paper<br />letterpaper<br />...</td><td>指定纸张大小</td><td>letterpaper</td></tr>
<tr><td>twoside<br />oneside</td><td>指定单面/双面排版。影响奇偶页的页眉页脚、页边距</td><td>article / report：oneside<br />book：twoside</td></tr>
<tr><td>onecolumn<br />twocolumn</td><td>指定单栏/双栏排版</td><td>onecolumn</td></tr>
<tr><td>openright<br />openany</td><td>指定新的一章 <code>\chapter</code> 是在奇数页（右侧）开始<br />还是直接紧跟着上一页开始</td><td>report：openany<br />book：openright</td></tr>
<tr><td>landscape</td><td>指定横向排版</td><td>纵向</td></tr>
<tr><td>titlepage<br />notitlepage</td><td>指定标题命令 <code>\maketitle</code> 是否生成单独的标题页</td><td>article：notitlepage<br />report / book：titlepage</td></tr>
<tr><td>fleqn</td><td>令行间公式左对齐</td><td>居中对齐</td></tr>
<tr><td>leqno</td><td>将公式编号放在左边</td><td>右边</td></tr>
<tr><td>draft<br />final</td><td>指定草稿/终稿模式<br />草稿模式下，断行不良（溢出）的地方会在行尾添加一个黑色方块</td><td>final</td></tr>
</tbody></table>
<h4 id="宏包"><a class="header" href="#宏包">宏包</a></h4>
<p><code>\usepackage[选项]{包名}</code></p>
<blockquote>
<p>可以一次性指定多个包，用逗号分隔</p>
</blockquote>
<p>在终端下查看宏包的文档：</p>
<pre><code class="language-shell">&gt; texdoc 包名
</code></pre>
<hr />
<h4 id="项目"><a class="header" href="#项目">项目</a></h4>
<table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody>
<tr><td>.tex</td><td></td></tr>
<tr><td>.sty</td><td>宏包文件</td></tr>
<tr><td>.cls</td><td>文档类文件</td></tr>
<tr><td>.bib</td><td>BIBTEX 参考文献数据库文件</td></tr>
<tr><td>.bst</td><td>BIBTEX 用到的参考文献格式模板</td></tr>
<tr><td>.log</td><td>排版引擎生成的日志文件，供排查错误使用</td></tr>
<tr><td>.aux</td><td>LATEX 生成的主辅助文件，记录交叉引用、目录、参考文献的引用等</td></tr>
<tr><td>.toc</td><td>LATEX 生成的目录记录文件</td></tr>
<tr><td>.lof</td><td>LATEX 生成的图片目录记录文件</td></tr>
<tr><td>.lot</td><td>LATEX 生成的表格目录记录文件</td></tr>
<tr><td>.bbl</td><td>BIBTEX 生成的参考文献记录文件</td></tr>
<tr><td>.blg</td><td>BIBTEX 生成的日志文件</td></tr>
<tr><td>.idx</td><td>LATEX 生成的供 makeindex 处理的索引记录文件</td></tr>
<tr><td>.ind</td><td>makeindex 处理 .idx 生成的用于排版的格式化索引文件</td></tr>
<tr><td>.ilg</td><td>makeindex 生成的日志文件</td></tr>
<tr><td>.out</td><td>hyperref 宏包生成的 PDF 书签记录文件</td></tr>
</tbody></table>
<h5 id="文件的组织方式"><a class="header" href="#文件的组织方式">文件的组织方式</a></h5>
<p>通过 <code>\include{文件名}</code> 在源代码中插入文件</p>
<p><code>\include</code> 在读入文件时会另起一页，<code>\input</code> 命令可以避免这一点</p>
<div style="break-before: page; page-break-before: always;"></div><h4 id="字符"><a class="header" href="#字符">字符</a></h4>
<p>空格和 Tab 视为空格。连续多个空格视为一个。行首空格忽略不计。</p>
<p>换行符视为空格。空行产生<strong>分段</strong>。连续多个空行视为一个。</p>
<p>注释 <code>%...</code></p>
<p>特殊字符 <code># $ % &amp; { } _ ^ ~ \</code>
输入特殊字符需要 <code>\# \$ \% \&amp; \{ \} \_ \^{} \~{} \textbackslash</code></p>
<h5 id="标点符号"><a class="header" href="#标点符号">标点符号</a></h5>
<p>中文标点一般可以直接打。西文标点：</p>
<p>引号：</p>
<pre><code class="language-latex">``text''
`text'
</code></pre>
<p>连字号 <code>-</code>
短破折号 <code>--</code>
长破折号 <code>---</code></p>
<p>省略号 <code>\ldots</code></p>
<p>拉丁文扩展与重音 :bookmark_tabs:</p>
<h4 id="断行和断页"><a class="header" href="#断行和断页">断行和断页</a></h4>
<p>西文排版中，排版引擎通常选择在空格处断行。通过 <code>~</code> 可以添加不允许断行的空格。</p>
<h5 id="手动断行命令"><a class="header" href="#手动断行命令">手动断行命令</a></h5>
<pre><code class="language-latex">\\[垂直间距]
\\*[垂直间距]	% 带星号：禁止在此处分页
\newline
</code></pre>
<h5 id="手动断页命令"><a class="header" href="#手动断页命令">手动断页命令</a></h5>
<pre><code class="language-latex">\newpage
\clearpage
</code></pre>
<p>双栏排版中，<code>\newpage</code> 会另起一栏。另外，两者在涉及浮动体的排版上行为不同</p>
<h5 id="给排版引擎提供建议的命令"><a class="header" href="#给排版引擎提供建议的命令">给排版引擎提供建议的命令</a></h5>
<pre><code class="language-latex">\linebreak[n]
\nolinebreak[n]

\pagebreak[n]
\nopagebreak[n]
</code></pre>
<p>数字 n 表示建议程度，范围 0-4。4 表示强制。缺省值为 4。</p>
<h5 id="断词命令西文"><a class="header" href="#断词命令西文">断词命令（西文）</a></h5>
<p>有时需要通过断词来换行。对于长单词，可以在其中添加 <code>\-</code> 来指定适合断词的位置</p>
<div style="break-before: page; page-break-before: always;"></div><h4 id="章节"><a class="header" href="#章节">章节</a></h4>
<p>划分章节的命令</p>
<pre><code class="language-latex">\chapter{标题}	% 仅用于 report 和 book
\section{标题}
\subsection{标题}
\subsubsection{标题}
\paragraph{标题}
\subparagraph{标题}
</code></pre>
<p>这些命令还会向目录中添加条目，影响页眉页脚的内容</p>
<p>可选参数 <code>[]</code> 指定在目录、页眉页脚中使用的短标题。加星号 <code>*</code> 后不带编号，不生成目录项和页眉页脚。
加星号的标题可以通过 <code>\addcontentsline{toc}{章节层次}{标题}</code> 手段生成目录项。</p>
<p><code>\part</code> 命令可以在不影响章节编号的情况下分割文档。</p>
<h4 id="目录"><a class="header" href="#目录">目录</a></h4>
<p><code>\tableofcontents</code></p>
<p>一些宏包 <code>tocbibind</code>，<code>titletoc</code>，<code>tocloft</code></p>
<h4 id="文档结构划分"><a class="header" href="#文档结构划分">文档结构划分</a></h4>
<p><code>\appendix</code> 命令将正文和附录分开。</p>
<p>book 文档类还提供了：</p>
<pre><code class="language-latex">\frontmatter	% 前言
\mainmater		% 正文
\backmatter		% 后记
</code></pre>
<h4 id="标题页"><a class="header" href="#标题页">标题页</a></h4>
<p>LaTeX 支持生成简单的标题页，不过一般不用，如下所示：</p>
<pre><code class="language-latex">\title{Test title}
\author{ Mary\thanks{E-mail:*****@***.com}
	\and Ted\thanks{Corresponding author}
	\and Louis
	}
\date{\today}

\maketitle
</code></pre>
<p>常利用 titlepage 环境重定义 <code>\maketitle</code> 命令</p>
<pre><code class="language-latex">\renewcommand{\maketitle}{
	\begin{titlepage}
	... % 用户自定义命令
	\end{titlepage}
}
</code></pre>
<h4 id="交叉引用"><a class="header" href="#交叉引用">交叉引用</a></h4>
<p>在能够被交叉引用的地方，如章节、公式、图表、定理等位置使用 <code>\label{标签名}</code> 命令
之后可以在别处使用 <code>\ref{标签名}</code> 或 <code>\pageref{标签名}</code> 命令，生成交叉引用的编号和页码</p>
<p><code>\label</code> 具体的使用位置是：</p>
<ol>
<li><strong>章节标题</strong> 在章节标题命令 \section 等之后紧接着使用。</li>
<li><strong>行间公式</strong> 单行公式在公式内任意位置使用；多行公式在每一行公式的任意位置使用。</li>
<li><strong>有序列表</strong> 在 enumerate 环境的每个 \item 命令之后、下一个 \item 命令之前任意位置使用。</li>
<li><strong>图表标题</strong> 在图表标题命令 \caption 之后紧接着使用。</li>
<li><strong>定理环境</strong> 在定理环境内部任意位置使用。</li>
</ol>
<h4 id="脚注"><a class="header" href="#脚注">脚注</a></h4>
<p><code>\footnote{脚注内容}</code></p>
<p>有些情况下（比如在表格环境、各种盒子内）使用 <code>\footnote</code> 并不能正确生成脚注。可以分两步进行，先使用 <code>\footnotemark</code> 为脚注计数，再在合适的位置用 <code>\footnotetext{脚注内容}</code> 生成脚注</p>
<h4 id="边注"><a class="header" href="#边注">边注</a></h4>
<p><code>\marginpar[左边注]{右边注}</code></p>
<p>如果只给定右边注，那么边注在奇偶页文字相同。如果给定了左边注，那么在偶数页使用左边注。</p>
<p>可用 <code>\marginpar{\footnotesize 边注}</code> 来减小字号</p>
<h4 id="列表"><a class="header" href="#列表">列表</a></h4>
<h5 id="有序列表-enumerate"><a class="header" href="#有序列表-enumerate">有序列表 enumerate</a></h5>
<pre><code class="language-latex">\begin{enumerate}
	\item An item.	
	\item Reference.
	\item[*] A starred item.
\end{enumerate}
</code></pre>
<p><code>\item</code> 可带一个可选参数，可以将符号替换成自定义的符号</p>
<p>有序列表的符号由命令 <code>\labelenumi</code> 到 <code>\labelenumiv</code> 定义，重新定义这些命令需要用到计数器相关命令</p>
<h5 id="无序列表-itemize"><a class="header" href="#无序列表-itemize">无序列表 itemize</a></h5>
<pre><code class="language-latex">\begin{itemize}
	\item An item.
	\item An item.
	\item[+] An item.
\end{itemize}
</code></pre>
<p>列表可以嵌套</p>
<p>各级无序列表的符号由命令 <code>\labelitemi</code> 到 <code>\labelitemiv</code> 定义，可以对其进行重定义：</p>
<pre><code class="language-latex">\renewcommand{\labelitemi}{\ddag}	% 一级无序列表的符号
\renewcommand{\labelitemii}{\dag}	% 二级无序列表的符号
</code></pre>
<p>可用 enumitem 宏包定制各种列表间距。enumitem 宏包还提供了对列表标签、引用等的定制。</p>
<h5 id="关键字环境-description"><a class="header" href="#关键字环境-description">关键字环境 description</a></h5>
<pre><code class="language-latex">\begin{description}
	\item[Enumerate] Numbered list.
	\item[Itemize] Non-numbered list.
\end{description}
</code></pre>
<h4 id="对齐环境"><a class="header" href="#对齐环境">对齐环境</a></h4>
<p>center、flushleft 和 flushright 环境分别用于生成居中、左对齐和右对齐的文本环境。</p>
<p>除此之外，还可以用 <code>\centering</code>, <code>\raggedright</code>, <code>\raggedleft</code> 命令直接改变文字的对齐方式，这种方式适合在浮动体环境内使用。</p>
<h4 id="引用环境"><a class="header" href="#引用环境">引用环境</a></h4>
<p>两种引用的环境：quote 用于引用较短的文字，首行不缩进；quotation 用于引用若干段文字，首行缩进</p>
<p>verse 用于排版诗歌，与 quotation 恰好相反，verse 是首行悬挂缩进的</p>
<h4 id="代码环境"><a class="header" href="#代码环境">代码环境</a></h4>
<p>代码环境 verbatim</p>
<p>要排版简短的代码或关键字，可使用 <code>\verb⟨delim⟩⟨code⟩⟨delim⟩</code> 命令。例如 <code>\verb|\LaTeX|</code></p>
<p>verbatim 宏包优化了 verbatim 环境的内部命令，并提供了 \verbatiminput 命令用来直接读入文件生成代码环境。fancyvrb 宏包提供了可定制格式的 Verbatim 环境；listings 宏包更进一步，可生成关键字高亮的代码环境，支持各种程序设计语言的语法和关键字。</p>
<h4 id="表格"><a class="header" href="#表格">表格</a></h4>
<p>排版表格最基本的 tabular 环境用法为：</p>
<pre><code class="language-latex">\begin{tabular}[对齐]{列格式}
⟨item1⟩ &amp; ⟨item2⟩ &amp; … \\
\hline
⟨item1⟩ &amp; ⟨item2⟩ &amp; … \\
\end{tabular}
</code></pre>
<p>直接使用 tabular 环境的话，会使表格与周围的文字混排。此时可选参数控制垂直对齐：<code>t</code> 表示按顶部对齐，<code>b</code> 表示按底部对齐，默认居中对齐。但是通常情况下会把 tabular 放在 table 浮动体环境中，并用 <code>\caption</code> 命令加标题。</p>
<h5 id="横线"><a class="header" href="#横线">横线</a></h5>
<p><code>\hline</code> 用来在行与行之间绘制横线</p>
<p><code>\cline{i-j}</code> 可以设置横线范围</p>
<h5 id="列格式"><a class="header" href="#列格式">列格式</a></h5>
<table><thead><tr><th>单元格描述</th><th>说明</th></tr></thead><tbody>
<tr><td>l</td><td>左对齐，不折行</td></tr>
<tr><td>c</td><td>居中对齐，不折行</td></tr>
<tr><td>r</td><td>右对齐，不折行</td></tr>
<tr><td>p{宽度}</td><td>固定宽度，自动折行，与其他行靠顶端对齐</td></tr>
<tr><td>m{宽度}</td><td>固定宽度，自动折行，与其他行居中对齐</td></tr>
<tr><td>b{宽度}</td><td>固定宽度，自动折行，与其他行靠底端对齐</td></tr>
</tbody></table>
<table><thead><tr><th>单元格间描述</th><th>说明</th></tr></thead><tbody>
<tr><td>|</td><td>绘制竖线</td></tr>
<tr><td>@{内容}</td><td>添加任意内容，会自动消除单元格前后添加的间距</td></tr>
</tbody></table>
<p>将格式进行重复 <code>*{重复次数}{格式参数}</code></p>
<p>整列修饰格式，比如整列改变为粗体，可以使用 array 宏包，用 <code>{}&gt;</code> 和 <code>&lt;{}</code> 给单元格前后加上修饰，例如：</p>
<pre><code class="language-latex">% \usepackage{array}
\begin{tabular}{&gt;{\itshape} r &lt;{*} l}
	\hline
	italic &amp; normal \\
	column &amp; column \\
	\hline
\end{tabular}
</code></pre>
<h5 id="三线表"><a class="header" href="#三线表">三线表</a></h5>
<p>需要引入 booktabs 宏包</p>
<pre><code class="language-latex">\begin{tabular}{llll}
	\toprule
	      &amp; A &amp; B &amp; C \\
	\midrule
	类别1 &amp; 0.1 &amp; 0.2 &amp; 0.3\\
	类别2 &amp; 0.1 &amp; 0.2 &amp; 0.3\\
	\bottomrule
\end{tabular}
</code></pre>
<h5 id="行距"><a class="header" href="#行距">行距</a></h5>
<pre><code class="language-latex">\begin{tabular}{c}
	\hline
	Head lines \\[6pt]
	tabular lines \\
	tabular lines \\
	\hline
\end{tabular}
</code></pre>
<p>复杂的列宽控制和单元格对齐 :bookmark_tabs:</p>
<p>合并和拆分单元格 :bookmark_tabs:</p>
<h4 id="图片"><a class="header" href="#图片">图片</a></h4>
<p>在调用了 graphicx 宏包以后，就可以使用 <code>\includegraphics[选项]{文件名}</code> 命令加载图片</p>
<table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody>
<tr><td>width=宽度</td><td>指定图片宽度</td></tr>
<tr><td>height=高度</td><td>指定图片高度</td></tr>
<tr><td>scale=倍数</td><td>图片缩放一定倍数</td></tr>
<tr><td>angle=角度</td><td>图片逆时针旋转一定角度</td></tr>
</tbody></table>
<p><code>\graphicspath{{路径}{路径}...}</code> 命令，用于声明一个或多个图片文件存放的目录</p>
<h4 id="盒子"><a class="header" href="#盒子">盒子</a></h4>
<div style="break-before: page; page-break-before: always;"></div><h4 id="syntonly"><a class="header" href="#syntonly">syntonly</a></h4>
<pre><code class="language-latex">\usepackage{syntonly}
\syntaxonly
</code></pre>
<p>可令 LaTeX 编译后不生成 DVI 或者 PDF 文档，只排查错误，加快编译速度</p>
<h4 id="titlesec"><a class="header" href="#titlesec">titlesec</a></h4>
<p>为 <code>\section</code> 等章节定制格式</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
