## 变量

rust 中的变量和函数使用 snake case 规范命名。

```rust
let x = 1;		// 不可变变量
let mut v = 2;	// 可变变量
const NUM: u32 = 12 * 2;	// 常量，必须注明类型
```

变量不能声明在全局作用域中，常量可以

可以重复声明同名变量，这会**隐藏**（Shadowing）先前的变量

```rust
let x = 1;
{
    let x = 12;
    println!("{x}");	// -> 12
}
let x = x + 1;
println!("{x}");	// -> 2
```

## 数据类型

- **标量**（scalar）类型：整型、浮点型、布尔类型、字符类型
- **复合**（compound）类型：元组、数组

#### 整型

| 长度（bit）      | 有符号  | 无符号  |
| ---------------- | ------- | ------- |
| 8                | `i8`    | `u8`    |
| 16               | `i16`   | `u16`   |
| 32               | `i32`   | `u32`   |
| 64               | `i64`   | `u64`   |
| 128              | `i128`  | `u128`  |
| arch（机器字长） | `isize` | `usize` |

| 字面值        | 说明       |
| ------------- | ---------- |
| `98_222`      | 10进制     |
| `0xff`        | 16进制     |
| `0o77`        | 8进制      |
| `0b1111_0000` | 2进制      |
| `b'A'`        | 字符（u8） |

整型溢出：在 debug 构建中，rust 会检查溢出并产生 panic。在 release 构建中，rust 不检查溢出。如果需要利用溢出行为，建议使用标准库的 `Wrapping` 类型。

#### 浮点型

| 长度（bit）  | 类型  |
| ------------ | ----- |
| 32（单精度） | `f32` |
| 64（双精度） | `f64` |

#### 布尔型

```rust
let b: bool = true;
let b: bool = false;
```

#### 字符类型

```rust
let c: char = '😈';
```

char 类型的大小是4个字节，表示 Unicode 值

#### 元组 tuple

长度和类型固定，类型不必相同

```rust
let tup: (i32, f32, u8) = (500, 1.0, b'A');
let tup = (1,);
```

模式匹配和解构

```rust
let (x, y, z) = tup;
let a = tup.0;
```

不包含任何值的元组 `()`，叫做**单元**（unit）元组。用于表示空值，如果一个表达式不返回任何值，则其隐式返回 `()`。

#### 数组 array

数组长度固定，在栈上分配

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
let a = [3; 5];		// 5个3
```

索引。越界会引起 panic。

```rust
a[3];
```

---

## 高级特性

#### 类型别名

```rust
type Kilometers = i32;
type Result<T> = std::result::Result<T, std::io::Error>;
```

类型别名不会创建出新的类型

#### never type

用 `!` 表示。充当从不返回的函数的返回值。从不返回的函数也叫发散函数。例子有 `continue`，`panic!`，没有 `break` 的 `loop` 等。`!` 类型可以转为任意类型，于是可以保证 `match` 分支的类型匹配。

#### 动态大小类型和 `Sized` trait

动态大小类型是在编译期不能确定大小的类型，例如 `str`、trait 对象。处理这种类型的方法是：必须将动态大小类型的值置于某种指针之后。例如 `&dyn Trait`、`Box<dyn Trait>`、`Rc<dyn Trait>`。

`Sized` trait 用于标识具有静态大小的类型，这个 trait 自动实现在编译期可以确定大小的类型上。Rust 隐式的为每一个泛型函数添加了 `Sized` bound，例如：

```rust
fn generic<T>(t: T)
```

事实上为：

```rust
fn generic<T: Sized>(t: T)
```

即限定了 `T` 必须是具有静态大小的类型。可以通过手动添加 `?Sized` 以解除这个限制，同时也就必须用某种指针来处理这个类型：

```rust
fn generic<T: ?Sized>(t: &T)
```

#### 原始标识符

原始标识符允许你使用关键字作为变量/函数名，加上 `r#` 前缀即可，例如：

```rust
fn r#match() {..}
let r#try = 1;
```

在定义和使用时都要加 `r#`。主要用于与其他语言交互。
